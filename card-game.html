<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ÌÅ¨Î°úÎãàÌÅ¥ ÎìÄÏñº - Chronicle Duel</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Segoe UI', sans-serif;
  background: #1a1a2e;
  color: #fff;
  overflow: hidden;
  height: 100vh;
  user-select: none;
}

/* ===== MAIN MENU ===== */
#main-menu {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
}

#main-menu h1 {
  font-size: 3em;
  margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(255,100,50,0.5);
}

#main-menu .subtitle {
  font-size: 1.2em;
  color: #aaa;
  margin-bottom: 40px;
}

.menu-btn {
  padding: 15px 0;
  width: 220px;
  margin: 10px;
  font-size: 1.2em;
  text-align: center;
  border: 2px solid #555;
  background: rgba(255,255,255,0.05);
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s;
}

.menu-btn:hover {
  background: rgba(255,255,255,0.15);
  border-color: #f0a;
  transform: scale(1.05);
}

/* ===== FACTION SELECT ===== */
#faction-select {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
}

#faction-select h2 {
  font-size: 2em;
  margin-bottom: 30px;
}

.faction-cards {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 960px;
}

.faction-card {
  width: 170px;
  padding: 20px;
  border: 3px solid #555;
  border-radius: 15px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s;
}

.faction-card:hover {
  transform: translateY(-10px);
}

.faction-card.human {
  background: linear-gradient(180deg, #2a1f0e, #1a1508);
  border-color: #c9a84c;
}

.faction-card.human:hover {
  box-shadow: 0 0 30px rgba(201,168,76,0.4);
}

.faction-card.demon {
  background: linear-gradient(180deg, #2e0a0a, #1a0505);
  border-color: #c0392b;
}

.faction-card.demon:hover {
  box-shadow: 0 0 30px rgba(192,57,43,0.4);
}

.faction-card.elf {
  background: linear-gradient(180deg, #0a2e1a, #051a0f);
  border-color: #2ecc71;
}
.faction-card.elf:hover {
  box-shadow: 0 0 30px rgba(46,204,113,0.4);
}

.faction-card.druid {
  background: linear-gradient(180deg, #2e1f0a, #1a1205);
  border-color: #e67e22;
}
.faction-card.druid:hover {
  box-shadow: 0 0 30px rgba(230,126,34,0.4);
}

.faction-card.dwarf {
  background: linear-gradient(180deg, #1a1a2e, #0f0f1a);
  border-color: #95a5a6;
}
.faction-card.dwarf:hover {
  box-shadow: 0 0 30px rgba(149,165,166,0.4);
}

.faction-icon {
  font-size: 3em;
  margin-bottom: 15px;
}

.faction-card h3 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.faction-card p {
  color: #aaa;
  font-size: 0.9em;
  line-height: 1.5;
}
.faction-power {
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px solid rgba(255,255,255,0.15);
  color: #ddd !important;
  font-size: 0.85em !important;
}

.back-btn {
  margin-top: 30px;
  padding: 10px 30px;
  background: rgba(255,255,255,0.1);
  border: 1px solid #555;
  color: #aaa;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1em;
}

.back-btn:hover {
  background: rgba(255,255,255,0.2);
  color: #fff;
}

/* ===== GAME BOARD ===== */
#game-board {
  display: none;
  flex-direction: column;
  height: 100vh;
  background: linear-gradient(180deg, #0d1117, #161b22, #0d1117);
  position: relative;
}

/* Top bar */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 15px;
  background: rgba(0,0,0,0.3);
  font-size: 0.85em;
  height: 35px;
}

.top-bar .game-info { color: #888; }
.top-bar .menu-link { color: #666; cursor: pointer; }
.top-bar .menu-link:hover { color: #fff; }

/* Player areas */
.player-area {
  display: flex;
  align-items: center;
  padding: 5px 15px;
  height: 60px;
  gap: 10px;
}

.player-area.opponent { background: rgba(100,0,0,0.1); }
.player-area.mine { background: rgba(0,0,100,0.1); }

.hero-portrait {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: 2px solid #555;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  flex-shrink: 0;
  position: relative;
  cursor: pointer;
}

.hero-portrait.human-hero { border-color: #c9a84c; background: #2a1f0e; }
.hero-portrait.demon-hero { border-color: #c0392b; background: #2e0a0a; }
.hero-portrait.elf-hero { border-color: #2ecc71; background: #0a2e1a; }
.hero-portrait.druid-hero { border-color: #e67e22; background: #2e1f0a; }
.hero-portrait.dwarf-hero { border-color: #95a5a6; background: #1a1a2e; }

.hero-portrait.targetable {
  animation: targetPulse 1s infinite;
  cursor: crosshair;
}

@keyframes targetPulse {
  0%, 100% { box-shadow: 0 0 5px rgba(255,0,0,0.5); }
  50% { box-shadow: 0 0 15px rgba(255,0,0,0.8); }
}

.hero-hp {
  position: absolute;
  bottom: -4px;
  right: -4px;
  background: #c0392b;
  color: #fff;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  font-size: 0.55em;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  border: 2px solid #1a1a2e;
}

.hero-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.hero-name {
  font-size: 0.9em;
  font-weight: bold;
}

.mana-bar {
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 0.75em;
}

.mana-crystal {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid #2980b9;
  background: transparent;
}

.mana-crystal.filled {
  background: #3498db;
  box-shadow: 0 0 4px rgba(52,152,219,0.5);
}

.mana-text {
  color: #3498db;
  font-weight: bold;
  margin-left: 5px;
}

.hero-power-btn {
  padding: 4px 12px;
  border-radius: 8px;
  border: 2px solid #555;
  background: rgba(255,255,255,0.05);
  color: #ccc;
  font-size: 0.75em;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  position: relative;
}

.hero-power-btn:hover:not(.used):not(.disabled) {
  background: rgba(255,255,255,0.15);
  border-color: #3498db;
}


.hero-power-btn.used {
  opacity: 0.4;
  cursor: not-allowed;
}

.hero-power-btn.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.deck-count {
  margin-left: auto;
  padding: 4px 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 5px;
  font-size: 0.8em;
  color: #888;
  cursor: pointer;
  transition: all 0.2s;
}

.deck-count:hover {
  background: rgba(255,255,255,0.12);
  color: #ccc;
}

#deck-viewer {
  display: none;
  position: absolute;
  right: 10px;
  bottom: 180px;
  width: 320px;
  max-height: 55vh;
  background: rgba(15,12,30,0.97);
  border: 2px solid #3498db;
  border-radius: 12px;
  z-index: 20;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 -5px 30px rgba(52,152,219,0.3);
  animation: dictSlideUp 0.25s ease-out;
}

/* Hand area */
.hand-area {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  padding: 5px 10px;
  min-height: 120px;
  gap: 0;
  overflow: visible;
  position: relative;
}

.hand-area.opponent-hand {
  min-height: 60px;
  align-items: flex-start;
}

/* Field area */
.field-area {
  display: flex;
  justify-content: center;
  align-items: center;
  flex: 1;
  gap: 5px;
  padding: 5px;
  min-height: 100px;
  border-top: 1px solid rgba(255,255,255,0.05);
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.field-area.opponent-field {
  background: rgba(200,0,0,0.03);
}

.field-area.my-field {
  background: rgba(0,0,200,0.03);
}

/* Card styles */
.card {
  width: 80px;
  min-width: 80px;
  height: 110px;
  border-radius: 8px;
  border: 2px solid #555;
  display: flex;
  flex-direction: column;
  position: relative;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  overflow: hidden;
  font-size: 0.7em;
}

.card.in-hand:hover {
  transform: translateY(-20px) scale(1.15) rotate(0deg) !important;
  z-index: 100 !important;
  box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}

.card.playable {
  border-color: #2ecc71;
  box-shadow: 0 0 8px rgba(46,204,113,0.3);
}

.card.human-card {
  background: linear-gradient(180deg, #3d2e10, #2a1f0e);
  border-color: #8b7340;
}

.card.demon-card {
  background: linear-gradient(180deg, #3d1010, #2e0a0a);
  border-color: #8b3030;
}

.card.elf-card {
  background: linear-gradient(180deg, #103d1a, #0a2e10);
  border-color: #308b50;
}

.card.druid-card {
  background: linear-gradient(180deg, #3d2a10, #2e1f0a);
  border-color: #8b6530;
}

.card.dwarf-card {
  background: linear-gradient(180deg, #252535, #1a1a2e);
  border-color: #6b7b8b;
}

.card.spell-card {
  border-style: dashed;
}

.card-back {
  width: 55px;
  min-width: 55px;
  height: 75px;
  border-radius: 6px;
  background: linear-gradient(135deg, #2c3e50, #34495e);
  border: 2px solid #4a6785;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  position: relative;
}
.card-back::after {
  content: attr(data-emoji);
  font-size: 7em;
  opacity: 0.5;
  filter: saturate(0.5) brightness(1.2);
  position: absolute;
  top: 44%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}
.card-back::before {
  content: '';
  position: absolute;
  inset: 4px;
  border: 1.5px solid rgba(255,255,255,0.15);
  border-radius: 4px;
  z-index: 1;
  pointer-events: none;
}

.card-back-human { background: linear-gradient(135deg, #3d2e0a, #5c4a1a); border-color: #c9a84c; }
.card-back-demon { background: linear-gradient(135deg, #3d0a0a, #5c1a1a); border-color: #c94c4c; }
.card-back-elf { background: linear-gradient(135deg, #0a3d1a, #1a5c2e); border-color: #4cc96a; }
.card-back-druid { background: linear-gradient(135deg, #3d2a0a, #5c3d1a); border-color: #c9884c; }
.card-back-dwarf { background: linear-gradient(135deg, #2a2a2a, #3d3d3d); border-color: #95a5a6; }

.card-mana {
  position: absolute;
  top: -1px;
  left: -1px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #2980b9;
  color: #fff;
  font-size: 0.9em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  border: 1px solid #1a5276;
}

.card-art {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  padding-top: 8px;
}

.card-name {
  text-align: center;
  font-size: 0.8em;
  font-weight: bold;
  padding: 1px 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card-desc {
  text-align: center;
  font-size: 0.65em;
  color: #aaa;
  padding: 1px 3px;
  min-height: 20px;
  line-height: 1.2;
}

.card-stats {
  display: flex;
  justify-content: space-between;
  padding: 0 2px 2px;
}

.card-attack, .card-health {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  font-size: 0.85em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
}

.card-attack {
  background: #e67e22;
  color: #fff;
  border: 1px solid #d35400;
}

.card-health {
  background: #c0392b;
  color: #fff;
  border: 1px solid #96281b;
}

/* Field minion */
.field-minion {
  width: 75px;
  min-width: 75px;
  height: 95px;
  border-radius: 8px;
  border: 2px solid #555;
  display: flex;
  flex-direction: column;
  position: relative;
  cursor: pointer;
  transition: all 0.2s;
  overflow: hidden;
  font-size: 0.7em;
}

.field-minion.human-card {
  background: linear-gradient(180deg, #3d2e10, #2a1f0e);
}

.field-minion.demon-card {
  background: linear-gradient(180deg, #3d1010, #2e0a0a);
}

.field-minion.elf-card {
  background: linear-gradient(180deg, #103d1a, #0a2e10);
}

.field-minion.druid-card {
  background: linear-gradient(180deg, #3d2a10, #2e1f0a);
}

.field-minion.dwarf-card {
  background: linear-gradient(180deg, #252535, #1a1a2e);
}

.field-minion.can-attack {
  border-color: #2ecc71;
  box-shadow: 0 0 8px rgba(46,204,113,0.4);
  cursor: pointer;
}

.field-minion.taunt {
  border-color: #f1c40f;
  border-width: 3px;
  box-shadow: 0 0 8px rgba(241,196,15,0.3);
}

.field-minion.targetable {
  animation: targetPulse 1s infinite;
  cursor: crosshair;
}

.field-minion.selected {
  border-color: #e74c3c;
  box-shadow: 0 0 15px rgba(231,76,60,0.6);
  transform: scale(1.05);
}

.field-minion .minion-art {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.8em;
}

.field-minion .minion-name {
  text-align: center;
  font-size: 0.7em;
  padding: 1px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.field-minion .minion-keywords {
  text-align: center;
  font-size: 0.6em;
  color: #f1c40f;
  height: 12px;
}

.field-minion .minion-stats {
  display: flex;
  justify-content: space-between;
  padding: 0 2px 2px;
}

.field-minion .minion-attack, .field-minion .minion-health {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  font-size: 0.85em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
}

.field-minion .minion-attack {
  background: #e67e22;
  color: #fff;
}

.field-minion .minion-health {
  background: #c0392b;
  color: #fff;
}

.field-minion .minion-health.damaged {
  background: #e74c3c;
}

/* End turn button */
.end-turn-btn {
  position: absolute;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  padding: 12px 20px;
  background: linear-gradient(180deg, #e67e22, #d35400);
  border: 2px solid #e67e22;
  color: #fff;
  font-size: 1em;
  font-weight: bold;
  border-radius: 25px;
  cursor: pointer;
  z-index: 10;
  transition: all 0.2s;
}

.end-turn-btn:hover {
  transform: translateY(-50%) scale(1.05);
  box-shadow: 0 0 15px rgba(230,126,34,0.5);
}

.end-turn-btn.disabled {
  background: #555;
  border-color: #555;
  cursor: not-allowed;
}

/* Center divider */
.board-divider {
  height: 3px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
  position: relative;
}

/* Turn transition overlay */
#turn-transition {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.95);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#turn-transition h2 {
  font-size: 2.5em;
  margin-bottom: 20px;
}

#turn-transition p {
  color: #aaa;
  margin-bottom: 30px;
}

#turn-transition button {
  padding: 15px 40px;
  font-size: 1.2em;
  background: #e67e22;
  border: none;
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
}

/* Game over overlay */
#game-over {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.95);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#game-over h2 {
  font-size: 3em;
  margin-bottom: 5px;
}

#game-over .result-text {
  font-size: 1.3em;
  margin-bottom: 20px;
  color: #aaa;
}

#game-over button {
  padding: 15px 0;
  width: 220px;
  font-size: 1.2em;
  background: #e67e22;
  border: none;
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
  margin: 5px;
  text-align: center;
}

/* VS Intro */
#vs-intro {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
  z-index: 2000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
.vs-container {
  display: flex;
  align-items: center;
  gap: 30px;
  position: relative;
}
.vs-fighter {
  display: flex;
  flex-direction: column;
  align-items: center;
  opacity: 0;
}
.vs-fighter.left { transform: translateX(-120px); }
.vs-fighter.right { transform: translateX(120px); }
.vs-fighter.animate-in-left {
  animation: vsSlideLeft 0.5s ease-out forwards;
}
.vs-fighter.animate-in-right {
  animation: vsSlideRight 0.5s ease-out forwards;
}
@keyframes vsSlideLeft {
  0% { opacity: 0; transform: translateX(-120px); }
  100% { opacity: 1; transform: translateX(0); }
}
@keyframes vsSlideRight {
  0% { opacity: 0; transform: translateX(120px); }
  100% { opacity: 1; transform: translateX(0); }
}
.vs-emoji {
  font-size: 5em;
  margin-bottom: 10px;
  filter: drop-shadow(0 0 15px rgba(255,255,255,0.3));
}
.vs-name {
  font-size: 1.6em;
  font-weight: bold;
  color: #eee;
  text-shadow: 0 0 10px rgba(255,255,255,0.3);
}
.vs-text {
  font-size: 4em;
  font-weight: bold;
  color: #e74c3c;
  text-shadow: 0 0 30px rgba(231,76,60,0.8), 0 0 60px rgba(231,76,60,0.4);
  opacity: 0;
  transform: scale(3);
}
.vs-text.animate-vs {
  animation: vsPop 0.4s ease-out 0.4s forwards;
}
@keyframes vsPop {
  0% { opacity: 0; transform: scale(3); }
  70% { opacity: 1; transform: scale(0.9); }
  100% { opacity: 1; transform: scale(1); }
}

/* Game Over Stats */
.game-over-stats {
  display: flex;
  gap: 30px;
  margin: 10px 0 20px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 10px;
  padding: 15px 25px;
  flex-wrap: wrap;
  justify-content: center;
}
.stats-turn-info {
  width: 100%;
  text-align: center;
  font-size: 1.1em;
  color: #aaa;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 5px;
}
.stats-column {
  text-align: center;
  min-width: 140px;
}
.stats-column h3 {
  font-size: 1.05em;
  margin-bottom: 10px;
  color: #eee;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}
.stat-row {
  display: flex;
  justify-content: space-between;
  gap: 15px;
  font-size: 0.9em;
  color: #999;
  padding: 4px 0;
}
.stat-row span:last-child {
  color: #f1c40f;
  font-weight: bold;
}
#game-over h2 {
  opacity: 0;
  transform: scale(0.5);
}
#game-over h2.animate-result {
  animation: resultPop 0.6s ease-out forwards;
}
@keyframes resultPop {
  0% { opacity: 0; transform: scale(0.5); }
  70% { opacity: 1; transform: scale(1.1); }
  100% { opacity: 1; transform: scale(1); }
}

/* Log area */
.log-area {
  position: absolute;
  left: 5px;
  top: 50%;
  transform: translateY(-50%);
  width: 180px;
  max-height: 200px;
  overflow-y: auto;
  background: rgba(0,0,0,0.5);
  border-radius: 8px;
  padding: 8px;
  font-size: 0.7em;
  color: #888;
  z-index: 5;
}

.log-area .log-entry {
  padding: 2px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

/* Damage animation */
.damage-flash {
  animation: damageFlash 0.3s ease-out;
}

@keyframes damageFlash {
  0% { filter: brightness(1); }
  50% { filter: brightness(3) hue-rotate(350deg); }
  100% { filter: brightness(1); }
}

.heal-flash {
  animation: healFlash 0.3s ease-out;
}

@keyframes healFlash {
  0% { filter: brightness(1); }
  50% { filter: brightness(2) hue-rotate(90deg); }
  100% { filter: brightness(1); }
}

/* Floating damage text */
.floating-text {
  position: absolute;
  font-size: 1.5em;
  font-weight: bold;
  pointer-events: none;
  z-index: 999;
  animation: floatUp 1s ease-out forwards;
}

.floating-text.damage { color: #e74c3c; }
.floating-text.heal { color: #2ecc71; }

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-40px) scale(1.5); }
}

/* Card draw animation */
.card-draw-anim {
  opacity: 0;
  transition: opacity 0.35s ease-out, transform 0.4s ease-out;
}

/* Summon animation */
.summon-anim {
  animation: summonPop 0.5s ease-out;
}

@keyframes summonPop {
  0% { opacity: 0; transform: scale(0) translateY(30px); box-shadow: 0 0 30px rgba(255,215,0,0.8); }
  40% { opacity: 1; transform: scale(1.2) translateY(-5px); box-shadow: 0 0 20px rgba(255,215,0,0.5); }
  70% { transform: scale(0.95) translateY(2px); }
  100% { opacity: 1; transform: scale(1) translateY(0); box-shadow: none; }
}

/* Attack animation */
.attack-anim {
  animation: attackLunge 0.3s ease-in-out;
}

@keyframes attackLunge {
  0% { transform: translateY(0); }
  40% { transform: translateY(-30px) scale(1.1); }
  100% { transform: translateY(0) scale(1); }
}

.attack-anim-down {
  animation: attackLungeDown 0.3s ease-in-out;
}

@keyframes attackLungeDown {
  0% { transform: translateY(0); }
  40% { transform: translateY(30px) scale(1.1); }
  100% { transform: translateY(0) scale(1); }
}

/* Battlecry flash */
.battlecry-flash {
  animation: battlecryGlow 0.5s ease-out;
}

@keyframes battlecryGlow {
  0% { box-shadow: 0 0 0px rgba(255, 215, 0, 0); }
  30% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), 0 0 50px rgba(255, 215, 0, 0.4); }
  100% { box-shadow: none; }
}

/* Screen flash for battlecry */
.screen-flash {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 998;
  animation: screenFlash 0.3s ease-out forwards;
}

@keyframes screenFlash {
  0% { background: rgba(255, 215, 0, 0.15); }
  100% { background: rgba(255, 215, 0, 0); }
}

/* Hero hit shake */
.hero-hit {
  animation: heroShake 0.3s ease-in-out;
}

@keyframes heroShake {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-5px); }
  40% { transform: translateX(5px); }
  60% { transform: translateX(-3px); }
  80% { transform: translateX(3px); }
}

/* AI Action Banner */
.ai-action-banner {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.85);
  color: #f1c40f;
  padding: 12px 30px;
  border-radius: 10px;
  font-size: 1.1em;
  font-weight: bold;
  z-index: 700;
  border: 2px solid rgba(241,196,15,0.3);
  pointer-events: none;
  animation: aiBannerFade 1.2s ease-out forwards;
  text-align: center;
  white-space: nowrap;
}
@keyframes aiBannerFade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
  15% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  70% { opacity: 1; }
  100% { opacity: 0; }
}

/* Card tooltip */
.card-tooltip {
  display: none;
  position: fixed;
  background: rgba(20,20,40,0.97);
  border: 2px solid #666;
  border-radius: 10px;
  padding: 12px;
  z-index: 500;
  width: 200px;
  pointer-events: none;
}

.card-tooltip .tooltip-name {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 5px;
}

.card-tooltip .tooltip-desc {
  color: #ccc;
  font-size: 0.9em;
  line-height: 1.4;
}

.card-tooltip .tooltip-stats {
  margin-top: 8px;
  color: #aaa;
  font-size: 0.85em;
}

/* Attack arrow */
.attack-arrow {
  position: fixed;
  pointer-events: none;
  z-index: 800;
}

.attack-line {
  stroke: #e74c3c;
  stroke-width: 3;
  stroke-dasharray: 8, 4;
  animation: dashMove 0.5s linear infinite;
}

@keyframes dashMove {
  to { stroke-dashoffset: -12; }
}

/* Coin card special */
.card.coin-card {
  border-color: #f1c40f;
  background: linear-gradient(180deg, #4a3f10, #2a2508);
}

/* Responsive */
@media (max-width: 768px) {
  .card { width: 65px; min-width: 65px; height: 95px; font-size: 0.6em; }
  .field-minion { width: 60px; min-width: 60px; height: 80px; font-size: 0.6em; }
  .card-back { width: 40px; min-width: 40px; height: 60px; }
  .card-back::after { font-size: 3.2em; }
  .log-area { display: none; }
}

/* Spell target selection */
.spell-target-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.3);
  z-index: 50;
}

.cancel-target {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 30px;
  background: #c0392b;
  border: none;
  color: #fff;
  border-radius: 8px;
  cursor: pointer;
  z-index: 60;
  font-size: 1em;
  display: none;
}

/* Card dictionary */
.dict-toggle {
  position: absolute;
  left: 15px;
  bottom: 130px;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 2px solid #8e44ad;
  background: rgba(142,68,173,0.2);
  color: #c39bd3;
  font-size: 1.3em;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 15;
}

.dict-toggle:hover {
  background: rgba(142,68,173,0.45);
  color: #fff;
  transform: scale(1.1);
  box-shadow: 0 0 12px rgba(142,68,173,0.5);
}

.dict-toggle.open {
  background: #8e44ad;
  color: #fff;
  border-color: #a569bd;
}

#card-dictionary {
  display: none;
  position: absolute;
  left: 10px;
  bottom: 180px;
  width: 320px;
  max-height: 55vh;
  background: rgba(15,12,30,0.97);
  border: 2px solid #8e44ad;
  border-radius: 12px;
  z-index: 20;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 -5px 30px rgba(142,68,173,0.3);
  animation: dictSlideUp 0.25s ease-out;
}

@keyframes dictSlideUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.dict-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  background: rgba(142,68,173,0.15);
  border-bottom: 1px solid rgba(142,68,173,0.3);
  flex-shrink: 0;
}

.dict-header h2 {
  font-size: 1em;
  margin: 0;
}

.dict-header .dict-subtitle {
  color: #888;
  font-size: 0.75em;
  margin: 0;
}

.dict-close-x {
  width: 26px;
  height: 26px;
  border-radius: 50%;
  border: none;
  background: rgba(255,255,255,0.1);
  color: #aaa;
  font-size: 1em;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.dict-close-x:hover {
  background: rgba(255,255,255,0.25);
  color: #fff;
}

.dict-body {
  overflow-y: auto;
  padding: 10px;
  flex: 1;
}

.dict-section {
  margin-bottom: 15px;
}

.dict-section h3 {
  font-size: 0.85em;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
  color: #c39bd3;
}

.dict-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px;
}

.dict-card {
  border-radius: 8px;
  border: 1px solid #444;
  padding: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.75em;
  transition: background 0.2s;
  cursor: default;
}

.dict-card:hover {
  background: rgba(255,255,255,0.05);
}

.dict-card.human-card {
  background: rgba(60,45,16,0.5);
  border-color: rgba(139,115,64,0.4);
}

.dict-card.demon-card {
  background: rgba(60,16,16,0.5);
  border-color: rgba(139,48,48,0.4);
}

.dict-card.elf-card {
  background: rgba(16,60,26,0.5);
  border-color: rgba(48,139,80,0.4);
}

.dict-card.druid-card {
  background: rgba(60,42,16,0.5);
  border-color: rgba(139,101,48,0.4);
}

.dict-card.dwarf-card {
  background: rgba(37,37,53,0.5);
  border-color: rgba(107,123,139,0.4);
}

.dict-card .dc-left {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex-shrink: 0;
  width: 36px;
}

.dict-card .dc-emoji {
  font-size: 1.5em;
  line-height: 1;
}

.dict-card .dc-mana {
  background: #2980b9;
  color: #fff;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.8em;
  margin-top: 2px;
}

.dict-card .dc-right {
  flex: 1;
  min-width: 0;
}

.dict-card .dc-name {
  font-weight: bold;
  font-size: 0.9em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dict-card .dc-desc {
  color: #999;
  font-size: 0.75em;
  line-height: 1.2;
  margin-top: 1px;
}

.dict-card .dc-stats {
  display: flex;
  gap: 4px;
  margin-top: 3px;
}

.dict-card .dc-atk, .dict-card .dc-hp {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.8em;
}

.dict-card .dc-atk {
  background: #e67e22;
  color: #fff;
}

.dict-card .dc-hp {
  background: #c0392b;
  color: #fff;
}

/* ===== PAUSE MENU ===== */
#pause-menu, #settings-menu {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
}

#pause-menu h2, #settings-menu h2 {
  font-size: 2em;
  margin-bottom: 20px;
}

.pause-btn {
  padding: 12px 0;
  width: 200px;
  font-size: 1.1em;
  border: 2px solid #555;
  background: rgba(255,255,255,0.08);
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.pause-btn:hover {
  background: rgba(255,255,255,0.18);
  border-color: #aaa;
  transform: scale(1.03);
}

.pause-btn-danger {
  border-color: #c0392b;
  color: #e74c3c;
}

.pause-btn-danger:hover {
  background: rgba(192,57,43,0.2);
  border-color: #e74c3c;
}

.settings-row {
  display: flex;
  align-items: center;
  gap: 15px;
  width: 260px;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 1em;
}

.settings-row input[type="range"] {
  flex: 1;
  accent-color: #e67e22;
}

/* Toggle switch */
.toggle-switch {
  position: relative;
  width: 48px;
  height: 26px;
}

.toggle-switch input { opacity: 0; width: 0; height: 0; }

.toggle-slider {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: #555;
  border-radius: 26px;
  cursor: pointer;
  transition: 0.3s;
}

.toggle-slider::before {
  content: '';
  position: absolute;
  width: 20px; height: 20px;
  left: 3px; bottom: 3px;
  background: #fff;
  border-radius: 50%;
  transition: 0.3s;
}

.toggle-switch input:checked + .toggle-slider {
  background: #e67e22;
}

.toggle-switch input:checked + .toggle-slider::before {
  transform: translateX(22px);
}

/* Mulligan */
#mulligan-screen {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a15 100%);
  z-index: 1500;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#mulligan-screen h2 { color: #ffd700; margin-bottom: 5px; }
.mulligan-cards {
  display: flex;
  gap: 15px;
  margin: 20px 0;
  flex-wrap: wrap;
  justify-content: center;
}
.mulligan-card {
  width: 100px;
  padding: 12px 8px;
  border-radius: 10px;
  background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
  border: 2px solid #555;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}
.mulligan-card:hover { border-color: #aaa; transform: translateY(-3px); }
.mulligan-card.selected {
  border-color: #555;
  opacity: 0.35;
  filter: grayscale(0.8);
}
.mulligan-card .m-cost {
  background: #3498db;
  color: white;
  border-radius: 50%;
  width: 24px; height: 24px;
  display: inline-flex;
  align-items: center; justify-content: center;
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 5px;
}
.mulligan-card .m-emoji { font-size: 32px; margin: 5px 0; }
.mulligan-card .m-name { font-size: 11px; color: #ddd; }
.mulligan-card .m-stats { font-size: 12px; color: #aaa; margin-top: 4px; }
#mulligan-confirm {
  padding: 10px 40px;
  font-size: 16px;
  background: linear-gradient(135deg, #e67e22, #d35400);
  border: none;
  border-radius: 8px;
  color: white;
  cursor: pointer;
  margin-top: 10px;
}
#mulligan-confirm:hover { filter: brightness(1.2); }
</style>
</head>
<body>

<!-- MAIN MENU -->
<div id="main-menu">
  <h1>ÌÅ¨Î°úÎãàÌÅ¥ ÎìÄÏñº</h1>
  <p class="subtitle">Chronicle Duel</p>
  <button class="menu-btn" onclick="playSound('click'); startGame('ai')">AI ÎåÄÏ†Ñ</button>
  <button class="menu-btn" onclick="playSound('click'); startGame('pvp')">2Ïù∏ ÎåÄÏ†Ñ</button>
  <button class="menu-btn" onclick="playSound('book'); openMenuDictionary()">üìñ Ïπ¥Îìú ÎèÑÍ∞ê</button>
  <button class="menu-btn" onclick="playSound('click'); openMenuSettings()">‚öôÔ∏è ÏÑ§Ï†ï</button>
</div>

<!-- MENU SETTINGS -->
<div id="menu-settings" style="display:none; flex-direction:column; align-items:center; justify-content:center; height:100vh; background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);">
  <h2 style="margin-bottom:30px;">‚öôÔ∏è ÏÑ§Ï†ï</h2>
  <div class="settings-row">
    <span>Ìö®Í≥ºÏùå</span>
    <label class="toggle-switch">
      <input type="checkbox" id="menu-sfx-toggle" checked onchange="toggleSfx(this.checked)">
      <span class="toggle-slider"></span>
    </label>
  </div>
  <div class="settings-row">
    <span>ÏùåÎüâ</span>
    <input type="range" id="menu-volume-slider" min="0" max="100" value="50" oninput="setVolume(this.value)">
    <span id="menu-volume-label">50%</span>
  </div>
  <div class="settings-row">
    <span>Î∞∞Í≤ΩÏùåÏïÖ</span>
    <label class="toggle-switch">
      <input type="checkbox" id="menu-bgm-toggle" checked onchange="toggleBGM(this.checked)">
      <span class="toggle-slider"></span>
    </label>
  </div>
  <div class="settings-row">
    <span>ÏùåÎüâ</span>
    <input type="range" id="menu-bgm-slider" min="0" max="100" value="50" oninput="setBGMVolume(this.value)">
    <span id="menu-bgm-label">50%</span>
  </div>
  <button class="back-btn" onclick="playSound('click'); closeMenuSettings()" style="margin-top:30px;">Îí§Î°ú</button>
</div>

<!-- MENU DICTIONARY: Faction Select -->
<div id="menu-dict-select" style="display:none; flex-direction:column; align-items:center; justify-content:center; height:100vh; background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);">
  <h2 style="margin-bottom:30px;">üìñ Ïπ¥Îìú ÎèÑÍ∞ê</h2>
  <div class="faction-cards" id="menu-dict-factions"></div>
  <button class="back-btn" onclick="playSound('book'); closeMenuDictSelect()" style="margin-top:30px;">Îí§Î°ú</button>
</div>

<!-- MENU DICTIONARY: Card List -->
<div id="menu-dictionary" style="display:none; flex-direction:column; align-items:center; height:100vh; background:linear-gradient(135deg,#0f0c29,#302b63,#24243e); padding:30px; overflow-y:auto;">
  <h2 id="menu-dict-title" style="margin-bottom:20px;">üìñ Ïπ¥Îìú ÎèÑÍ∞ê</h2>
  <div id="menu-dict-content" style="width:100%; max-width:700px;"></div>
  <button class="back-btn" onclick="playSound('book'); backToMenuDictSelect()" style="margin-top:20px; margin-bottom:30px;">Îí§Î°ú</button>
</div>

<!-- FACTION SELECT -->
<div id="faction-select">
  <h2>ÏÑ∏Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h2>
  <div class="faction-cards">
    <div class="faction-card human" onclick="selectFaction('human')">
      <div class="faction-icon">‚öîÔ∏è</div>
      <h3>Ïù∏Í∞Ñ</h3>
      <p>Ïã†ÏÑ±Ìïú ÎßàÎ≤ïÍ≥º Í∏∞ÏÇ¨Îã®Ïùò Ìûò</p>
      <p class="faction-power">‚ú® Ï≤¥Î†• 3 ÌöåÎ≥µ</p>
    </div>
    <div class="faction-card demon" onclick="selectFaction('demon')">
      <div class="faction-icon">üëø</div>
      <h3>ÏïÖÎßà</h3>
      <p>ÏßÄÏò•Ïùò Íµ∞Îã®Í≥º Ïñ¥Îë†Ïùò Ìûò</p>
      <p class="faction-power">üíÄ ÏûêÌï¥ 2, ÎìúÎ°úÏö∞ 1</p>
    </div>
    <div class="faction-card elf" onclick="selectFaction('elf')">
      <div class="faction-icon">üßù</div>
      <h3>ÏóòÌîÑ</h3>
      <p>Ïà≤Ïùò Ï†ïÎ∞ÄÌïú Í∂ÅÏà†Í≥º ÎßàÎ≤ï</p>
      <p class="faction-power">üèπ Ï†Å ÎØ∏ÎãàÏñ∏ 1ÎéÄ</p>
    </div>
    <div class="faction-card druid" onclick="selectFaction('druid')">
      <div class="faction-icon">üåø</div>
      <h3>ÎìúÎ£®Ïù¥Îìú</h3>
      <p>ÏûêÏó∞Í≥º ÏïºÏàòÏùò ÏõêÏãúÏ†Å Ìûò</p>
      <p class="faction-power">üêøÔ∏è 1/1 Îã§ÎûåÏ•ê ÏÜåÌôò</p>
    </div>
    <div class="faction-card dwarf" onclick="selectFaction('dwarf')">
      <div class="faction-icon">‚õèÔ∏è</div>
      <h3>ÎìúÏõåÌîÑ</h3>
      <p>Í¥ëÏÇ∞Ïùò Í∏∞Ïà†Í≥º Í∞ïÏ≤†Ïùò Ìûò</p>
      <p class="faction-power">üõ°Ô∏è ÏïÑÍµ∞ Ï†ÑÏ≤¥ Ï≤¥Î†•+1</p>
    </div>
  </div>
  <button class="back-btn" onclick="playSound('click'); factionSelectBack()">Îí§Î°ú</button>
</div>

<!-- GAME BOARD -->
<div id="game-board">
  <div class="top-bar">
    <span class="game-info" id="turn-info">ÌÑ¥ 1</span>
    <span class="game-info" id="game-mode-info"></span>
    <span class="menu-link" onclick="openPauseMenu()">Î©îÎâ¥</span>
  </div>

  <!-- Opponent area -->
  <div class="player-area opponent">
    <div class="hero-portrait" id="opponent-hero" onclick="targetHero('opponent')">
      <span id="opponent-hero-icon">üëø</span>
      <div class="hero-hp" id="opponent-hp">30</div>
    </div>
    <div class="hero-info">
      <span class="hero-name" id="opponent-name">ÏïÖÎßà</span>
      <div class="mana-bar" id="opponent-mana-bar"></div>
    </div>
    <div class="hero-power-btn disabled" id="opponent-power-btn">ÏòÅÏõÖ Îä•Î†•</div>
    <div class="deck-count" id="opponent-deck-count">Îç±: 27</div>
  </div>

  <div class="hand-area opponent-hand" id="opponent-hand"></div>

  <div class="field-area opponent-field" id="opponent-field"></div>

  <div class="board-divider"></div>
  <button class="end-turn-btn" id="end-turn-btn" onclick="endTurn()">ÌÑ¥ Ï¢ÖÎ£å</button>

  <div class="field-area my-field" id="my-field"></div>

  <div class="hand-area" id="my-hand"></div>

  <div class="player-area mine">
    <div class="hero-portrait" id="my-hero" onclick="targetHero('mine')">
      <span id="my-hero-icon">‚öîÔ∏è</span>
      <div class="hero-hp" id="my-hp">30</div>
    </div>
    <div class="hero-info">
      <span class="hero-name" id="my-name">Ïù∏Í∞Ñ</span>
      <div class="mana-bar" id="my-mana-bar"></div>
    </div>
    <button class="hero-power-btn" id="my-power-btn" onclick="useHeroPower()">ÏòÅÏõÖ Îä•Î†• (2)</button>
    <div class="deck-count" id="my-deck-count" onclick="toggleDeckViewer()">Îç±: 27</div>
  </div>

  <!-- Deck Viewer -->
  <div id="deck-viewer">
    <div class="dict-header" style="background:rgba(52,152,219,0.15); border-color:rgba(52,152,219,0.3);">
      <div>
        <h2 id="deck-viewer-title">ÎÇ®ÏùÄ Ïπ¥Îìú</h2>
        <p class="dict-subtitle" id="deck-viewer-subtitle"></p>
      </div>
      <button class="dict-close-x" onclick="toggleDeckViewer()">‚úï</button>
    </div>
    <div class="dict-body" id="deck-viewer-content"></div>
  </div>

  <div class="log-area" id="game-log"></div>

  <!-- Dictionary toggle + panel -->
  <button class="dict-toggle" id="dict-toggle" onclick="toggleDictionary()">üìñ</button>
  <div id="card-dictionary">
    <div class="dict-header">
      <div>
        <h2 id="dict-title">Ïπ¥Îìú ÎèÑÍ∞ê</h2>
        <p class="dict-subtitle" id="dict-subtitle"></p>
      </div>
      <button class="dict-close-x" onclick="toggleDictionary()">‚úï</button>
    </div>
    <div class="dict-body" id="dict-content"></div>
  </div>
</div>

<!-- Turn transition (for PVP) -->
<div id="turn-transition">
  <h2 id="transition-text"></h2>
  <p>ÌôîÎ©¥ÏùÑ ÏÉÅÎåÄÏóêÍ≤å ÎÑòÍ≤®Ï£ºÏÑ∏Ïöî</p>
  <button onclick="confirmTurnTransition()">Ï§ÄÎπÑ ÏôÑÎ£å</button>
</div>

<!-- Pause Menu -->
<div id="pause-menu">
  <h2>ÏùºÏãúÏ†ïÏßÄ</h2>
  <button class="pause-btn" onclick="playSound('click'); closePauseMenu()">Í≥ÑÏÜç</button>
  <button class="pause-btn" onclick="playSound('click'); openSettings()">ÏÑ§Ï†ï</button>
  <button class="pause-btn" onclick="playSound('gamestart'); closePauseMenu(); rematch();">Îã§ÏãúÌïòÍ∏∞</button>
  <button class="pause-btn pause-btn-danger" onclick="playSound('click'); closePauseMenu(); showMainMenu();">Î©îÏù∏ Î©îÎâ¥</button>
</div>

<!-- Settings Menu -->
<div id="settings-menu">
  <h2>ÏÑ§Ï†ï</h2>
  <div class="settings-row">
    <span>Ìö®Í≥ºÏùå</span>
    <label class="toggle-switch">
      <input type="checkbox" id="sfx-toggle" checked onchange="toggleSfx(this.checked)">
      <span class="toggle-slider"></span>
    </label>
  </div>
  <div class="settings-row">
    <span>ÏùåÎüâ</span>
    <input type="range" id="volume-slider" min="0" max="100" value="50" oninput="setVolume(this.value)">
    <span id="volume-label">50%</span>
  </div>
  <div class="settings-row">
    <span>Î∞∞Í≤ΩÏùåÏïÖ</span>
    <label class="toggle-switch">
      <input type="checkbox" id="bgm-toggle" checked onchange="toggleBGM(this.checked)">
      <span class="toggle-slider"></span>
    </label>
  </div>
  <div class="settings-row">
    <span>ÏùåÎüâ</span>
    <input type="range" id="bgm-slider" min="0" max="100" value="50" oninput="setBGMVolume(this.value)">
    <span id="bgm-label">50%</span>
  </div>
  <button class="pause-btn" onclick="playSound('click'); closeSettings()">Îí§Î°ú</button>
</div>

<!-- VS Intro -->
<div id="vs-intro">
  <div class="vs-container">
    <div class="vs-fighter left" id="vs-left">
      <div class="vs-emoji" id="vs-emoji-left"></div>
      <div class="vs-name" id="vs-name-left"></div>
    </div>
    <div class="vs-text" id="vs-text">VS</div>
    <div class="vs-fighter right" id="vs-right">
      <div class="vs-emoji" id="vs-emoji-right"></div>
      <div class="vs-name" id="vs-name-right"></div>
    </div>
  </div>
</div>

<!-- Mulligan -->
<div id="mulligan-screen">
  <h2 id="mulligan-title">ÍµêÌôòÌï† Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h2>
  <p id="mulligan-subtitle" style="color:#aaa; margin-bottom:20px;">Î≤ÑÎ¶¥ Ïπ¥ÎìúÎ•º ÌÅ¥Î¶≠ÌïòÎ©¥ ÏÉà Ïπ¥ÎìúÎ°ú ÍµêÏ≤¥Îê©ÎãàÎã§</p>
  <div id="mulligan-cards" class="mulligan-cards"></div>
  <button id="mulligan-confirm" onclick="confirmMulligan()">ÌôïÏù∏</button>
</div>

<!-- Game Over -->
<div id="game-over">
  <h2 id="game-over-title"></h2>
  <p class="result-text" id="game-over-text"></p>
  <div class="game-over-stats" id="game-over-stats"></div>
  <button onclick="playSound('gamestart'); rematch()">Ïû¨ÎåÄÏ†Ñ</button>
  <button onclick="showMainMenu()">Î©îÏù∏ Î©îÎâ¥</button>
</div>

<!-- Cancel target button -->
<button class="cancel-target" id="cancel-target-btn" onclick="cancelTargeting()">Ï∑®ÏÜå</button>

<!-- Tooltip -->
<!-- AI Action Banner -->
<div class="ai-action-banner" id="ai-action-banner"></div>

<div class="card-tooltip" id="card-tooltip">
  <div class="tooltip-name"></div>
  <div class="tooltip-desc"></div>
  <div class="tooltip-stats"></div>
</div>

<!-- SVG for attack arrow -->
<svg class="attack-arrow" id="attack-arrow" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:800;">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c" />
    </marker>
  </defs>
  <line id="arrow-line" class="attack-line" x1="0" y1="0" x2="0" y2="0" marker-end="url(#arrowhead)" />
</svg>

<script>
// ===== SOUND EFFECTS (Web Audio API) =====
let audioCtx = null;
let sfxEnabled = true;
let sfxVolume = 0.5;

function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playSound(type) {
  if (!sfxEnabled) return;
  try {
    const ctx = getAudioCtx();
    const now = ctx.currentTime;
    const vol = sfxVolume;

    switch(type) {
      case 'summon': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.15);
        gain.gain.setValueAtTime(0.2 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.2);
        break;
      }
      case 'attack': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(60, now + 0.15);
        gain.gain.setValueAtTime(0.3 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.15);
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
        const noise = ctx.createBufferSource();
        const ng = ctx.createGain();
        noise.buffer = buf;
        ng.gain.setValueAtTime(0.15 * vol, now);
        ng.gain.linearRampToValueAtTime(0, now + 0.1);
        noise.connect(ng).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.1);
        break;
      }
      case 'spell': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
        gain.gain.setValueAtTime(0.15 * vol, now);
        gain.gain.linearRampToValueAtTime(0.2 * vol, now + 0.1);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.3);
        break;
      }
      case 'heropower': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(350, now);
        osc.frequency.setValueAtTime(500, now + 0.1);
        gain.gain.setValueAtTime(0.12 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.2);
        break;
      }
      case 'death': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.25);
        gain.gain.setValueAtTime(0.2 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.3);
        break;
      }
      case 'endturn': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(660, now);
        gain.gain.setValueAtTime(0.1 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.15);
        break;
      }
      case 'victory': {
        const notes = [523, 659, 784, 1047];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, now + i * 0.12);
          gain.gain.setValueAtTime(0.15 * vol, now + i * 0.12);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.12 + 0.25);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.12); osc.stop(now + i * 0.12 + 0.25);
        });
        break;
      }
      case 'defeat': {
        // Ìå®Î∞∞ - ÌïòÍ∞ï Ïä¨Ìîà ÌÜ§
        const notes = [400, 350, 300, 200];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + i * 0.15);
          gain.gain.setValueAtTime(0.12 * vol, now + i * 0.15);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.15 + 0.3);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.15); osc.stop(now + i * 0.15 + 0.3);
        });
        break;
      }
      case 'click': {
        // Î∂ÄÎìúÎü¨Ïö¥ "ÌÜ°" - ÏßßÏùÄ ÎÖ∏Ïù¥Ï¶à Î≤ÑÏä§Ìä∏ + ÏÇ¥Ïßù ÌÜ§
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.04, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
        const noise = ctx.createBufferSource();
        noise.buffer = buf;
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 4000;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.35 * vol, now);
        ng.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
        noise.connect(filter).connect(ng).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.04);
        break;
      }
      case 'book': {
        // Ï±Ö ÎÑòÍ∏∞Îäî ÏÜåÎ¶¨ - ÌïÑÌÑ∞Îìú ÎÖ∏Ïù¥Ï¶à
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.25, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
        const noise = ctx.createBufferSource();
        noise.buffer = buf;
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(3000, now);
        filter.frequency.linearRampToValueAtTime(1500, now + 0.2);
        filter.Q.value = 0.8;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.3 * vol, now + 0.03);
        gain.gain.linearRampToValueAtTime(0.15 * vol, now + 0.1);
        gain.gain.linearRampToValueAtTime(0, now + 0.25);
        noise.connect(filter).connect(gain).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.25);
        break;
      }
      case 'draw': {
        // Ïπ¥Îìú ÎΩëÍ∏∞ - ÏßßÏùÄ "Ïä•" Ïä§ÏôÄÏù¥ÌîÑ
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.12, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
        const noise = ctx.createBufferSource();
        noise.buffer = buf;
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(2000, now);
        filter.frequency.linearRampToValueAtTime(5000, now + 0.1);
        filter.Q.value = 1.5;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.3 * vol, now);
        ng.gain.linearRampToValueAtTime(0, now + 0.12);
        noise.connect(filter).connect(ng).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.12);
        break;
      }
      case 'error': {
        // ÎßàÎÇò Î∂ÄÏ°± - ÎÇÆÏùÄ "ÎóëÎóë" Í±∞Ï†àÏùå
        [0, 0.12].forEach(t => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'square';
          osc.frequency.value = 200;
          g.gain.setValueAtTime(0.15 * vol, now + t);
          g.gain.linearRampToValueAtTime(0, now + t + 0.08);
          osc.connect(g).connect(ctx.destination);
          osc.start(now + t); osc.stop(now + t + 0.08);
        });
        break;
      }
      case 'taunt': {
        // ÎèÑÎ∞ú Í≤ΩÍ≥† - Î¨µÏßÅÌïú "Îë•" Í≤ΩÍ≥†Ïùå
        const osc = ctx.createOscillator();
        const g = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.2);
        g.gain.setValueAtTime(0.25 * vol, now);
        g.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.connect(g).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.3);
        break;
      }
      case 'buff': {
        // Î≤ÑÌîÑ/Ìûê - Î∞ùÏùÄ ÏÉÅÏäπ "Îù†ÎßÅ"
        const notes = [523, 659, 784];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          g.gain.setValueAtTime(0.12 * vol, now + i * 0.08);
          g.gain.linearRampToValueAtTime(0, now + i * 0.08 + 0.15);
          osc.connect(g).connect(ctx.destination);
          osc.start(now + i * 0.08); osc.stop(now + i * 0.08 + 0.15);
        });
        break;
      }
      case 'debuff': {
        // ÎîîÎ≤ÑÌîÑ/Í≥µÍ≤© Ï£ºÎ¨∏ - Ïñ¥ÎëêÏö¥ ÌïòÍ∞ï "Ï•¨ÏõÖ"
        const osc = ctx.createOscillator();
        const g = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(150, now + 0.25);
        g.gain.setValueAtTime(0.12 * vol, now);
        g.gain.linearRampToValueAtTime(0, now + 0.3);
        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(2000, now);
        lp.frequency.linearRampToValueAtTime(400, now + 0.25);
        osc.connect(lp).connect(g).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.3);
        break;
      }
      case 'coin': {
        // ÎèôÏ†Ñ Ïß§Îûë - Í≥†Ïùå Í∏àÏÜçÏÑ± "Ï∞∞Îûë"
        [0, 0.06].forEach(t => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = t === 0 ? 1800 : 2400;
          g.gain.setValueAtTime(0.15 * vol, now + t);
          g.gain.exponentialRampToValueAtTime(0.001, now + t + 0.15);
          osc.connect(g).connect(ctx.destination);
          osc.start(now + t); osc.stop(now + t + 0.15);
        });
        break;
      }
      case 'gamestart': {
        // Í∏∞ÎåÄÍ∞ê ÏûàÎäî ÏÉÅÏäπ ÏïÑÎ•¥ÌéòÏßÄÏò§
        const notes = [330, 440, 554, 659, 880];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, now + i * 0.08);
          gain.gain.setValueAtTime(0.085 * vol, now + i * 0.08);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.08 + 0.2);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.08); osc.stop(now + i * 0.08 + 0.2);
        });
        // ÎßàÎ¨¥Î¶¨ ÌôîÏùå
        [880, 1108, 1320].forEach(freq => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + 0.4);
          gain.gain.setValueAtTime(0.04 * vol, now + 0.4);
          gain.gain.linearRampToValueAtTime(0, now + 0.8);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + 0.4); osc.stop(now + 0.8);
        });
        break;
      }
    }
  } catch(e) {}
}

// ===== BGM (Web Audio API) =====
let bgmEnabled = true;
let bgmVolume = 0.5;
let bgmNodes = null;
let bgmInterval = null;
let currentBGMTrack = null;

const BGM_TRACKS = {
  menu: {
    // Î©îÏù∏ ÌÖåÎßà: ÏûîÏûîÌïú ÌåêÌÉÄÏßÄ ÌïòÌîÑ ÏïÑÎ•¥ÌéòÏßÄÏò§
    patterns: [
      [220, 261.6, 329.6, 440, 329.6, 261.6],
      [196, 293.7, 349.2, 440, 349.2, 293.7],
      [164.8, 246.9, 329.6, 493.9, 329.6, 246.9],
      [440, 392, 329.6, 293.7, 261.6, 220],
    ],
    tempo: 600,
    noteDecay: 1.2,
    noteVol: 0.35,
    harmonicVol: 0.08,
    waveform: 'triangle',
  },
  battle: {
    // Î∞∞ÌãÄ ÌÖåÎßà: Ïñ¥Îë°Í≥† Í∏¥Ïû•Í∞ê ÏûàÎäî ÎßàÏù¥ÎÑà ÏßÑÌñâ
    patterns: [
      // Am ÏÉÅÏäπ
      [220, 246.9, 261.6, 293.7, 329.6, 293.7, 261.6, 0],
      // Dm ÌùêÎ¶Ñ
      [293.7, 329.6, 349.2, 329.6, 293.7, 261.6, 246.9, 0],
      // E Í∏¥Ïû•
      [329.6, 311.1, 329.6, 349.2, 392, 349.2, 329.6, 0],
      // Am ÌïòÍ∞ï Ìï¥Í≤∞
      [440, 392, 349.2, 329.6, 293.7, 261.6, 246.9, 220],
    ],
    tempo: 450,
    noteDecay: 0.55,
    noteVol: 0.28,
    harmonicVol: 0.1,
    waveform: 'triangle',
  },
  victory: {
    // ÏäπÎ¶¨: ÎπµÎπ†Î†à Í∞úÏÑ†ÌñâÏßÑ Ïä§ÌÉÄÏùº
    patterns: [
      // Îπ†-Îπ†Îπ†Îπ†~ Ìå°ÌååÎ†à ÎèÑÏûÖ
      [392, 392, 523.3, 392, 523.3, 659.3, 0, 659.3],
      // Î∞òÎ≥µ ÏÉÅÏäπ
      [523.3, 523.3, 659.3, 523.3, 659.3, 784, 0, 784],
      // ÌñâÏßÑ Î¶¨Îì¨
      [659.3, 784, 659.3, 784, 1047, 784, 1047, 0],
      // ÎßàÎ¨¥Î¶¨ Ìå°ÌååÎ†à
      [523.3, 659.3, 784, 1047, 0, 1047, 1047, 1047],
    ],
    tempo: 300,
    noteDecay: 0.5,
    noteVol: 0.35,
    harmonicVol: 0.15,
    waveform: 'triangle',
  },
  defeat: {
    // Ìå®Î∞∞: Ïä¨ÌîÑÏßÄÎßå ÎòêÎ†∑Ìïú AÎã®Ï°∞
    patterns: [
      // ÌïòÍ∞ï ÌõÑ ÏÇ¥Ïßù ÏÉÅÏäπ
      [440, 392, 329.6, 293.7, 329.6, 0],
      // Îã§Ïãú ÎÇ¥Î†§Í∞ê
      [392, 349.2, 293.7, 261.6, 293.7, 0],
      // ÌïúÌÉÑÌïòÎìØ Ïò¨ÎùºÍ∞îÎã§
      [329.6, 349.2, 392, 329.6, 293.7, 0],
      // Ï≤¥ÎÖêÌïòÎ©∞ ÎßàÎ¨¥Î¶¨
      [293.7, 261.6, 246.9, 220, 0, 0],
    ],
    tempo: 550,
    noteDecay: 1.0,
    noteVol: 0.38,
    harmonicVol: 0.12,
    waveform: 'triangle',
  },
};

function playBGM(track) {
  track = track || currentBGMTrack || 'menu';
  if (currentBGMTrack === track && bgmNodes) return; // Í∞ôÏùÄ Ìä∏Îûô Ïû¨ÏÉù Ï§ëÏù¥Î©¥ Î¨¥Ïãú
  stopBGM();
  currentBGMTrack = track;
  if (!bgmEnabled) return;
  try {
    const ctx = getAudioCtx();
    const masterGain = ctx.createGain();
    masterGain.gain.value = bgmVolume * 0.24;
    masterGain.connect(ctx.destination);

    const cfg = BGM_TRACKS[track];
    let patIdx = 0;
    let noteIdx = 0;

    function playNote() {
      if (!bgmEnabled || !bgmNodes) return;
      const pattern = cfg.patterns[patIdx];
      const freq = pattern[noteIdx];

      if (freq > 0) {
        const osc = ctx.createOscillator();
        const noteGain = ctx.createGain();
        osc.type = cfg.waveform;
        osc.frequency.value = freq;
        const t = ctx.currentTime;
        noteGain.gain.setValueAtTime(cfg.noteVol, t);
        noteGain.gain.exponentialRampToValueAtTime(0.01, t + cfg.noteDecay);
        osc.connect(noteGain).connect(masterGain);
        osc.start(t);
        osc.stop(t + cfg.noteDecay + 0.05);

        // Ïò•ÌÉÄÎ∏å ÏúÑ ÏûîÌñ•
        const osc2 = ctx.createOscillator();
        const ng2 = ctx.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2;
        ng2.gain.setValueAtTime(cfg.harmonicVol, t);
        ng2.gain.exponentialRampToValueAtTime(0.001, t + cfg.noteDecay * 0.6);
        osc2.connect(ng2).connect(masterGain);
        osc2.start(t);
        osc2.stop(t + cfg.noteDecay * 0.65);
      }

      noteIdx++;
      if (noteIdx >= pattern.length) {
        noteIdx = 0;
        patIdx = (patIdx + 1) % cfg.patterns.length;
      }
    }

    bgmInterval = setInterval(playNote, cfg.tempo);
    playNote();

    bgmNodes = { masterGain, ctx };
  } catch(e) {}
}

function stopBGM() {
  if (bgmInterval) { clearInterval(bgmInterval); bgmInterval = null; }
  if (bgmNodes) {
    try {
      bgmNodes.masterGain.disconnect();
    } catch(e) {}
    bgmNodes = null;
  }
}

function updateBGMVolume(v) {
  bgmVolume = v;
  if (bgmNodes) {
    bgmNodes.masterGain.gain.value = bgmVolume * 0.24;
  }
}

// ===== CARD DEFINITIONS =====
const HUMAN_CARDS = [
  // Minions
  { id:'h1', name:'ÏàòÎ†®ÏÉù', type:'minion', cost:1, attack:1, health:2, emoji:'üßë‚Äçüéì', desc:'', keywords:[] },
  { id:'h2', name:'ÎØºÎ≥ëÎåÄ', type:'minion', cost:1, attack:2, health:1, emoji:'üßë‚Äçüåæ', desc:'', keywords:[] },
  { id:'h3', name:'ÏÑ±Í∏∞ÏÇ¨', type:'minion', cost:2, attack:2, health:3, emoji:'üõ°Ô∏è', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'h4', name:'Í∂ÅÏàò', type:'minion', cost:2, attack:3, health:1, emoji:'üèπ', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'h5', name:'ÏπòÏú†ÏÇ¨', type:'minion', cost:2, attack:1, health:4, emoji:'üíö', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÏòÅÏõÖ Ï≤¥Î†• 3 ÌöåÎ≥µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); showHeroFloatingText(player, '+3', 'heal'); addLog(`ÏπòÏú†ÏÇ¨Í∞Ä ÏòÅÏõÖ Ï≤¥Î†•ÏùÑ 3 ÌöåÎ≥µ!`); } },
  { id:'h6', name:'Í∏∞ÏÇ¨', type:'minion', cost:3, attack:3, health:3, emoji:'‚öîÔ∏è', desc:'', keywords:[] },
  { id:'h7', name:'ÏÑ±Ï†ÑÏÇ¨', type:'minion', cost:3, attack:2, health:4, emoji:'‚úùÔ∏è', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'h8', name:'ÏïîÏÇ¥Ïûê', type:'minion', cost:3, attack:4, health:2, emoji:'üó°Ô∏è', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'h9', name:'ÎåÄÎßàÎ≤ïÏÇ¨', type:'minion', cost:4, attack:3, health:5, emoji:'üßô', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'h10', name:'ÏÑ±Í∏∞ÏÇ¨ ÎåÄÏû•', type:'minion', cost:4, attack:4, health:4, emoji:'üè∞', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'h11', name:'ÎπõÏùò ÏàòÌò∏Ïûê', type:'minion', cost:5, attack:3, health:7, emoji:'üëº', desc:'ÏÉùÎ™ÖÎ†• Ìù°Ïàò', keywords:['lifesteal'] },
  { id:'h12', name:'Ïö©Í∏∞ÏÇ¨', type:'minion', cost:6, attack:5, health:5, emoji:'üêâ', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'h13', name:'ÎåÄÏ≤úÏÇ¨', type:'minion', cost:7, attack:6, health:7, emoji:'üòá', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÏòÅÏõÖ Ï≤¥Î†• 4 ÌöåÎ≥µ, ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ Ï≤¥Î†• 2 ÌöåÎ≥µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 4); showHeroFloatingText(player, '+4', 'heal'); gs[player].field.forEach(m => { const heal = Math.min(2, m.maxHealth - m.currentHealth); m.currentHealth = Math.min(m.maxHealth, m.currentHealth + 2); if (heal > 0) showFloatingText(m.uid, `+${heal}`, 'heal'); }); addLog(`ÎåÄÏ≤úÏÇ¨Í∞Ä ÏòÅÏõÖ Ï≤¥Î†• 4 ÌöåÎ≥µ, ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ Ï≤¥Î†• 2 ÌöåÎ≥µ!`); } },
  // Spells
  { id:'h14', name:'Ïã†ÏÑ±Ìïú Îπõ', type:'spell', cost:1, emoji:'‚ú®', desc:'ÏïÑÍµ∞ Ï∫êÎ¶≠ÌÑ∞ ÌïòÎÇòÏùò Ï≤¥Î†• 4 ÌöåÎ≥µ', target:'friendly_any', effect:'heal', value:4 },
  { id:'h15', name:'Ï≤úÎ≤å', type:'spell', cost:3, emoji:'‚ö°', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 4 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:4 },
  { id:'h16', name:'Ïã†Ïùò Î∂ÑÎÖ∏', type:'spell', cost:5, emoji:'üå©Ô∏è', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'none', effect:'aoe_damage', value:3 },
  { id:'h17', name:'Ï∂ïÎ≥µ', type:'spell', cost:2, emoji:'üôè', desc:'ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const DEMON_CARDS = [
  // Minions
  { id:'d1', name:'ÏûÑÌîÑ', type:'minion', cost:1, attack:3, health:1, emoji:'üëπ', desc:'', keywords:[] },
  { id:'d2', name:'Î∞ïÏ•ê', type:'minion', cost:1, attack:1, health:2, emoji:'ü¶á', desc:'', keywords:[] },
  { id:'d3', name:'ÏßÄÏò• Í∞êÏãúÏûê', type:'minion', cost:2, attack:2, health:3, emoji:'üëÅÔ∏è', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'d4', name:'Í∑∏Î¶ºÏûê ÏûêÍ∞ù', type:'minion', cost:2, attack:3, health:1, emoji:'üåë', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'d5', name:'Ìù°ÌòàÍ∑Ä', type:'minion', cost:2, attack:1, health:3, emoji:'üßõ', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÏòÅÏõÖ 3ÎéÄ, ÏûêÌï¥ 2ÎéÄ', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 3; gs.stats[player].totalDamage += 3; showHeroFloatingText(opp, '-3', 'damage'); gs[player].hp -= 2; showHeroFloatingText(player, '-2', 'damage'); addLog(`Ìù°ÌòàÍ∑ÄÍ∞Ä Ï†Å ÏòÅÏõÖÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ! ÏûêÌï¥ 2 Îç∞ÎØ∏ÏßÄ!`); } },
  { id:'d6', name:'ÏÑúÌÅêÎ≤ÑÏä§', type:'minion', cost:3, attack:3, health:3, emoji:'üòà', desc:'', keywords:[] },
  { id:'d7', name:'ÏÑùÏÉÅ ÏàòÌò∏Ïûê', type:'minion', cost:3, attack:2, health:4, emoji:'üóø', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'d8', name:'ÏßÄÏò• ÏÇ¨ÎÉ•Í∞ú', type:'minion', cost:3, attack:4, health:2, emoji:'üêï‚Äçü¶∫', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'d9', name:'ÏïÖÎßà ÎßàÎ≤ïÏÇ¨', type:'minion', cost:4, attack:3, health:5, emoji:'üîÆ', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'d10', name:'ÏßÄÏò• ÏàòÎ¨∏Ïû•', type:'minion', cost:4, attack:4, health:4, emoji:'üö™', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'d11', name:'ÏòÅÌòº Ìù°ÏàòÏûê', type:'minion', cost:5, attack:5, health:5, emoji:'üëª', desc:'ÏÉùÎ™ÖÎ†• Ìù°Ïàò', keywords:['lifesteal'] },
  { id:'d12', name:'ÏßÄÏò•Î∂à Ï†ïÎ†π', type:'minion', cost:6, attack:5, health:5, emoji:'üî•', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'d13', name:'ÏïÖÎßà Íµ∞Ï£º', type:'minion', cost:7, attack:6, health:7, emoji:'üëø', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÏòÅÏõÖ 4ÎéÄ, ÏûêÌï¥ 2ÎéÄ', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 4; gs.stats[player].totalDamage += 4; showHeroFloatingText(opp, '-4', 'damage'); gs[player].hp -= 2; showHeroFloatingText(player, '-2', 'damage'); addLog(`ÏïÖÎßà Íµ∞Ï£ºÍ∞Ä Ï†Å ÏòÅÏõÖÏóêÍ≤å 4 Îç∞ÎØ∏ÏßÄ! ÏûêÌï¥ 2 Îç∞ÎØ∏ÏßÄ!`); } },
  // Spells
  { id:'d14', name:'Ïñ¥Îë†Ïùò ÌôîÏÇ¥', type:'spell', cost:1, emoji:'üè¥', desc:'Ï†Å Ï∫êÎ¶≠ÌÑ∞ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', target:'enemy_any', effect:'damage', value:2 },
  { id:'d15', name:'ÏòÅÌòº Î∂àÍΩÉ', type:'spell', cost:3, emoji:'üíÄ', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 4 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:4 },
  { id:'d16', name:'ÏßÄÏò•Ïùò Î∂àÍ∏∏', type:'spell', cost:5, emoji:'üåã', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'none', effect:'aoe_damage', value:3 },
  { id:'d17', name:'Ïñ¥Îë† Í∞ïÌôî', type:'spell', cost:2, emoji:'üí™', desc:'ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const ELF_CARDS = [
  // Minions
  { id:'e1', name:'ÏöîÏ†ï Ï†ïÏ∞∞Î≥ë', type:'minion', cost:1, attack:1, health:2, emoji:'üßö', desc:'', keywords:[] },
  { id:'e2', name:'Ïà≤Ïùò Í∂ÅÏàò', type:'minion', cost:1, attack:2, health:1, emoji:'üèπ', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'e3', name:'ÎÇòÎ¨¥ Î∞©Ìå®Î≥ë', type:'minion', cost:2, attack:2, health:3, emoji:'üå≥', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'e4', name:'Í∑∏Î¶ºÏûê ÏÇ¨ÎÉ•Íæº', type:'minion', cost:2, attack:3, health:1, emoji:'üåô', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'e5', name:'Îã¨Îπõ ÏπòÏú†ÏÇ¨', type:'minion', cost:2, attack:1, health:3, emoji:'üåõ', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÏòÅÏõÖ Ï≤¥Î†• 3 ÌöåÎ≥µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); showHeroFloatingText(player, '+3', 'heal'); addLog(`Îã¨Îπõ ÏπòÏú†ÏÇ¨Í∞Ä ÏòÅÏõÖ Ï≤¥Î†•ÏùÑ 3 ÌöåÎ≥µ!`); } },
  { id:'e6', name:'ÏóòÌîÑ Í≤ÄÏÇ¨', type:'minion', cost:3, attack:3, health:3, emoji:'‚öîÔ∏è', desc:'', keywords:[] },
  { id:'e7', name:'Í≥†ÎåÄ ÏàòÌò∏Ïûê', type:'minion', cost:3, attack:2, health:4, emoji:'üå≤', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'e8', name:'Î∞îÎûå Ï∂îÏ†ÅÏûê', type:'minion', cost:3, attack:3, health:3, emoji:'üí®', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'e9', name:'Î≥ÑÎπõ ÎßàÎ≤ïÏÇ¨', type:'minion', cost:4, attack:3, health:5, emoji:'‚≠ê', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'e10', name:'Ïà≤Ïùò ÌååÏàòÍæº', type:'minion', cost:4, attack:4, health:4, emoji:'ü¶å', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'e11', name:'ÏÉùÎ™ÖÏùò Ï†ïÎ†π', type:'minion', cost:5, attack:4, health:6, emoji:'üçÉ', desc:'ÏÉùÎ™ÖÎ†• Ìù°Ïàò', keywords:['lifesteal'] },
  { id:'e12', name:'ÏùÄÎπõ Ïö©ÏÇ¨', type:'minion', cost:6, attack:6, health:4, emoji:'ü¶Ö', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'e13', name:'Ïà≤Ïùò Ïó¨Ïôï', type:'minion', cost:7, attack:6, health:7, emoji:'üëë', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÏòÅÏõÖ Ï≤¥Î†• 5 ÌöåÎ≥µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 5); showHeroFloatingText(player, '+5', 'heal'); addLog(`Ïà≤Ïùò Ïó¨ÏôïÏù¥ ÏòÅÏõÖ Ï≤¥Î†•ÏùÑ 5 ÌöåÎ≥µ!`); } },
  // Spells
  { id:'e14', name:'Îã¨Îπõ ÌôîÏÇ¥', type:'spell', cost:1, emoji:'üèπ', desc:'Ï†Å Ï∫êÎ¶≠ÌÑ∞ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', target:'enemy_any', effect:'damage', value:2 },
  { id:'e15', name:'Î≥ÑÏùò Î∂ÑÎÖ∏', type:'spell', cost:3, emoji:'üåü', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 4 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:4 },
  { id:'e16', name:'ÏûêÏó∞Ïùò Ïã¨Ìåê', type:'spell', cost:5, emoji:'üåä', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'none', effect:'aoe_damage', value:3 },
  { id:'e17', name:'Ïà≤Ïùò Ï∂ïÎ≥µ', type:'spell', cost:2, emoji:'üåø', desc:'ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const DRUID_CARDS = [
  // Minions
  { id:'dr1', name:'ÎÑàÍµ¨Î¶¨', type:'minion', cost:1, attack:1, health:2, emoji:'ü¶ù', desc:'', keywords:[] },
  { id:'dr2', name:'ÎèÖÎ±Ä', type:'minion', cost:1, attack:2, health:1, emoji:'üêç', desc:'', keywords:[] },
  { id:'dr3', name:'Í±∞Î∂ÅÏù¥ ÏàòÌò∏Ïûê', type:'minion', cost:2, attack:2, health:3, emoji:'üê¢', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'dr4', name:'Îß§', type:'minion', cost:2, attack:3, health:1, emoji:'ü¶Ö', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'dr5', name:'ÏπòÏú†Ïùò ÎÇòÎ¨¥', type:'minion', cost:2, attack:1, health:3, emoji:'üå≥', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÏòÅÏõÖ Ï≤¥Î†• 3 ÌöåÎ≥µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); showHeroFloatingText(player, '+3', 'heal'); addLog(`ÏπòÏú†Ïùò ÎÇòÎ¨¥Í∞Ä ÏòÅÏõÖ Ï≤¥Î†•ÏùÑ 3 ÌöåÎ≥µ!`); } },
  { id:'dr6', name:'ÎäëÎåÄ ÎåÄÏû•', type:'minion', cost:3, attack:2, health:3, emoji:'üê∫', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ +1 Í≥µÍ≤©', keywords:[], battlecry: (gs, player) => { gs[player].field.forEach(m => { m.currentAttack += 1; showFloatingText(m.uid, '+1', 'heal'); }); addLog(`ÎäëÎåÄ ÎåÄÏû•Ïùò Ï†ÑÌà¨ Ìï®ÏÑ±! ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ Í≥µÍ≤©Î†• +1!`); } },
  { id:'dr7', name:'ÎÇòÎ¨¥ Ï†ïÎ†π', type:'minion', cost:3, attack:2, health:4, emoji:'üå¥', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'dr8', name:'ÏïºÏÉù Î©ßÎèºÏßÄ', type:'minion', cost:3, attack:4, health:2, emoji:'üêó', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'dr9', name:'ÎèÖÏàòÎ¶¨ ÌòÑÏûê', type:'minion', cost:4, attack:3, health:5, emoji:'ü¶â', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'dr10', name:'Í≥∞ ÏàòÌò∏Ïûê', type:'minion', cost:4, attack:4, health:4, emoji:'üêª', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'dr11', name:'Î±ÄÌååÏù¥Ïñ¥ Î∞ïÏ•ê', type:'minion', cost:5, attack:4, health:6, emoji:'ü¶á', desc:'ÏÉùÎ™ÖÎ†• Ìù°Ïàò', keywords:['lifesteal'] },
  { id:'dr12', name:'ÎèåÏßÑ ÏΩîÎøîÏÜå', type:'minion', cost:6, attack:5, health:5, emoji:'ü¶è', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'dr13', name:'Í≥†ÎåÄ ÎÇòÎ¨¥Ï†ïÎ†π', type:'minion', cost:7, attack:5, health:7, emoji:'üåç', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: 1/1 Îã§ÎûåÏ•ê 3ÎßàÎ¶¨ ÏÜåÌôò', keywords:[], battlecry: (gs, player) => { for (let i = 0; i < 3 && gs[player].field.length < 7; i++) { const sq = { id:'squirrel_token', name:'Îã§ÎûåÏ•ê', type:'minion', cost:0, attack:1, health:1, emoji:'üêøÔ∏è', desc:'', keywords:[], uid: Date.now()+Math.random()+i, currentHealth:1, maxHealth:1, currentAttack:1, canAttack:false, summonedThisTurn:true, attacksThisTurn:0 }; gs[player].field.push(sq); } playSound('summon'); addLog(`Í≥†ÎåÄ ÎÇòÎ¨¥Ï†ïÎ†πÏùò Ï†ÑÌà¨ Ìï®ÏÑ±! Îã§ÎûåÏ•ê ÏÜåÌôò!`); } },
  // Spells
  { id:'dr14', name:'Í∞ÄÏãú Îç©Íµ¥', type:'spell', cost:1, emoji:'üåµ', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:3 },
  { id:'dr15', name:'ÏûêÏó∞Ïùò Î∂ÑÎÖ∏', type:'spell', cost:3, emoji:'üçÇ', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 4 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:4 },
  { id:'dr16', name:'Ìè≠ÌíçÏùò Îàà', type:'spell', cost:5, emoji:'üå™Ô∏è', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'none', effect:'aoe_damage', value:3 },
  { id:'dr17', name:'ÏïºÏÉùÏùò Ìûò', type:'spell', cost:2, emoji:'üí™', desc:'ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å +3/+1', target:'friendly_minion', effect:'buff_atk', value:3 },
];

const DWARF_CARDS = [
  // Minions
  { id:'dw1', name:'Í¥ëÎ∂Ä Í≤¨ÏäµÏÉù', type:'minion', cost:1, attack:1, health:3, emoji:'‚õèÔ∏è', desc:'', keywords:[] },
  { id:'dw2', name:'ÌôîÏïΩ Í∏∞Ïà†Ïûê', type:'minion', cost:1, attack:2, health:1, emoji:'üí£', desc:'', keywords:[] },
  { id:'dw3', name:'Ï≤†Î≤Ω ÏàòÎπÑÎ≥ë', type:'minion', cost:2, attack:2, health:3, emoji:'üõ°Ô∏è', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'dw4', name:'Ï¶ùÍ∏∞ ÎèåÍ≤©Î≥ë', type:'minion', cost:2, attack:3, health:1, emoji:'üí®', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'dw5', name:'ÏàòÎ¶¨Í≥µ', type:'minion', cost:2, attack:1, health:3, emoji:'üîß', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: ÏïÑÍµ∞ ÏòÅÏõÖ Ï≤¥Î†• 3 ÌöåÎ≥µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); showHeroFloatingText(player, '+3', 'heal'); addLog(`ÏàòÎ¶¨Í≥µÏù¥ ÏòÅÏõÖ Ï≤¥Î†•ÏùÑ 3 ÌöåÎ≥µ!`); } },
  { id:'dw6', name:'Ï≤†Ìá¥ Ï†ÑÏÇ¨', type:'minion', cost:3, attack:3, health:3, emoji:'üî®', desc:'', keywords:[] },
  { id:'dw7', name:'Í∞ïÏ≤† Í≥®Î†ò', type:'minion', cost:3, attack:2, health:5, emoji:'ü§ñ', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'dw8', name:'Ìè≠ÌååÎ≥ë', type:'minion', cost:3, attack:4, health:2, emoji:'üß®', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'dw9', name:'ÎåÄÌè¨ Í∏∞Ïà†Ïûê', type:'minion', cost:4, attack:3, health:5, emoji:'üí•', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 2 Îç∞ÎØ∏ÏßÄ', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'dw10', name:'ÎØ∏Ïä§Î¶¥ ÏàòÌò∏Ïûê', type:'minion', cost:4, attack:4, health:4, emoji:'üè∞', desc:'ÎèÑÎ∞ú', keywords:['taunt'] },
  { id:'dw11', name:'Ï¶ùÍ∏∞ Ìù°ÏàòÍ∏∞', type:'minion', cost:5, attack:3, health:8, emoji:'‚öôÔ∏è', desc:'ÏÉùÎ™ÖÎ†• Ìù°Ïàò', keywords:['lifesteal'] },
  { id:'dw12', name:'Ï†ÑÏ∞®', type:'minion', cost:6, attack:4, health:6, emoji:'üöÇ', desc:'ÎèåÏßÑ', keywords:['rush'] },
  { id:'dw13', name:'Í∏∞Í≥Ñ Íµ∞Ï£º', type:'minion', cost:7, attack:6, health:7, emoji:'ü¶æ', desc:'Ï†ÑÌà¨ Ìï®ÏÑ±: Ï†Å ÏòÅÏõÖÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 3; gs.stats[player].totalDamage += 3; showHeroFloatingText(opp, '-3', 'damage'); addLog(`Í∏∞Í≥Ñ Íµ∞Ï£ºÍ∞Ä Ï†Å ÏòÅÏõÖÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ!`); } },
  // Spells
  { id:'dw14', name:'Ìè≠ÌÉÑ Ìà¨Ï≤ô', type:'spell', cost:1, emoji:'üí£', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:3 },
  { id:'dw15', name:'Ïö©Ïïî Î∂ÑÏ∂ú', type:'spell', cost:3, emoji:'üåã', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 4 Îç∞ÎØ∏ÏßÄ', target:'enemy_minion', effect:'damage', value:4 },
  { id:'dw16', name:'ÎåÄÌè≠Î∞ú', type:'spell', cost:5, emoji:'üî•', desc:'Ï†Å ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ÏóêÍ≤å 3 Îç∞ÎØ∏ÏßÄ', target:'none', effect:'aoe_damage', value:3 },
  { id:'dw17', name:'Í∞ïÏ≤† Í∞ïÌôî', type:'spell', cost:2, emoji:'üõ°Ô∏è', desc:'ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const FACTION_CONFIG = {
  human: { name:'Ïù∏Í∞Ñ', cardClass:'human-card', heroClass:'human-hero', emoji:'‚öîÔ∏è', powerName:'ÏÑ±Ïä§Îü¨Ïö¥ Îπõ', powerDesc:'ÏòÅÏõÖ Ï≤¥Î†• 3 ÌöåÎ≥µ', cards: HUMAN_CARDS },
  demon: { name:'ÏïÖÎßà', cardClass:'demon-card', heroClass:'demon-hero', emoji:'üëø', powerName:'ÏÉùÎ™Ö Ï∞©Ï∑®', powerDesc:'ÏûêÌï¥ 2ÎéÄ, Ïπ¥Îìú 1Ïû• ÎìúÎ°úÏö∞', cards: DEMON_CARDS },
  elf:   { name:'ÏóòÌîÑ', cardClass:'elf-card', heroClass:'elf-hero', emoji:'üßù', powerName:'Îã¨Îπõ ÌôîÏÇ¥', powerDesc:'Ï†Å ÎØ∏ÎãàÏñ∏ 1ÎéÄ (ÏóÜÏúºÎ©¥ Ï†Å ÏòÅÏõÖ 1ÎéÄ)', cards: ELF_CARDS },
  druid: { name:'ÎìúÎ£®Ïù¥Îìú', cardClass:'druid-card', heroClass:'druid-hero', emoji:'üåø', powerName:'ÏïºÏÉùÏùò Î∂ÄÎ¶Ñ', powerDesc:'1/1 Îã§ÎûåÏ•ê ÏÜåÌôò', cards: DRUID_CARDS },
  dwarf: { name:'ÎìúÏõåÌîÑ', cardClass:'dwarf-card', heroClass:'dwarf-hero', emoji:'‚õèÔ∏è', powerName:'Ïû•Í∞ë Í∞ïÌôî', powerDesc:'ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ +1 Ï≤¥Î†• (ÏóÜÏúºÎ©¥ ÏòÅÏõÖ 2 ÌöåÎ≥µ)', cards: DWARF_CARDS },
};

const COIN_CARD = { id:'coin', name:'ÎèôÏ†Ñ', type:'spell', cost:0, emoji:'ü™ô', desc:'Ïù¥Î≤à ÌÑ¥ ÎßàÎÇò 1 ÌöçÎìù', target:'none', effect:'coin', value:1 };

// ===== GAME STATE =====
let gameState = null;
let gameMode = 'ai'; // 'ai' or 'pvp'
let selectedFaction = 'human';
let pvpP1Faction = null;
let selectedAttacker = null;
let targetingSpell = null;
let battlecryTarget = null;
let logs = [];

function createDeck(faction) {
  const cards = FACTION_CONFIG[faction].cards;
  let allCards = [];
  // 2 copies of each card
  cards.forEach(c => {
    allCards.push({...c, uid: Math.random().toString(36).substr(2,9)});
    allCards.push({...c, uid: Math.random().toString(36).substr(2,9)});
  });

  // Group cards by cost tiers
  const tiers = [
    allCards.filter(c => c.cost <= 2),  // Ï¥àÎ∞ò (1-2 ÏΩîÏä§Ìä∏)
    allCards.filter(c => c.cost === 3),  // Ï§ëÏ¥àÎ∞ò (3 ÏΩîÏä§Ìä∏)
    allCards.filter(c => c.cost === 4),  // Ï§ëÎ∞ò (4 ÏΩîÏä§Ìä∏)
    allCards.filter(c => c.cost >= 5),   // ÌõÑÎ∞ò (5+ ÏΩîÏä§Ìä∏)
  ];

  // Shuffle within each tier
  tiers.forEach(tier => {
    for (let i = tier.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tier[i], tier[j]] = [tier[j], tier[i]];
    }
  });

  // Build deck: high cost at bottom (index 0), low cost on top (end)
  // deck.pop() draws from end, so low cost cards are drawn first
  let deck = [...tiers[3], ...tiers[2], ...tiers[1], ...tiers[0]];

  // Add slight randomness: swap ~20% of adjacent cards to avoid being too predictable
  for (let i = 0; i < deck.length - 1; i++) {
    if (Math.random() < 0.2) {
      [deck[i], deck[i+1]] = [deck[i+1], deck[i]];
    }
  }

  return deck;
}

function initGame() {
  const p1Faction = selectedFaction;
  let p2Faction;
  if (window._vsOpponent) {
    p2Faction = window._vsOpponent;
    window._vsOpponent = null;
  } else {
    const otherFactions = Object.keys(FACTION_CONFIG).filter(f => f !== selectedFaction);
    p2Faction = otherFactions[Math.floor(Math.random() * otherFactions.length)];
  }

  gameState = {
    turn: 0,
    currentPlayer: 'p1',
    p1: {
      faction: p1Faction,
      hp: 30,
      maxMana: 0,
      mana: 0,
      deck: createDeck(p1Faction),
      hand: [],
      field: [],
      heroPowerUsed: false,
    },
    p2: {
      faction: p2Faction,
      hp: 30,
      maxMana: 0,
      mana: 0,
      deck: createDeck(p2Faction),
      hand: [],
      field: [],
      heroPowerUsed: false,
    },
    gameOver: false,
    winner: null,
    stats: {
      p1: { totalDamage: 0, minionsPlayed: 0, spellsCast: 0, heroPowerUsed: 0, cardsDrawn: 0 },
      p2: { totalDamage: 0, minionsPlayed: 0, spellsCast: 0, heroPowerUsed: 0, cardsDrawn: 0 },
    },
  };

  logs = [];
  addLog('Í≤åÏûÑ ÏãúÏûë!');
  addLog(`${getFactionName(p1Faction)} vs ${getFactionName(p2Faction)}`);

  // Draw starting hands
  for (let i = 0; i < 3; i++) drawCard('p1');
  for (let i = 0; i < 4; i++) drawCard('p2');

  // P2 gets the coin
  gameState.p2.hand.push({...COIN_CARD, uid: 'coin_' + Math.random().toString(36).substr(2,9)});

  playBGM('battle');

  // Î©ÄÎ¶¨Í±¥ Îã®Í≥Ñ ÏãúÏûë
  startMulligan('p1');
}

function getFactionName(f) { return FACTION_CONFIG[f].name; }
function getFactionClass(f) { return FACTION_CONFIG[f].cardClass; }
function getHeroClass(f) { return FACTION_CONFIG[f].heroClass; }
function getHeroEmoji(f) { return FACTION_CONFIG[f].emoji; }
function getHeroPowerName(f) { return FACTION_CONFIG[f].powerName; }

// ===== MULLIGAN =====
let mulliganPlayer = null;
let mulliganSelected = new Set();

function startMulligan(player) {
  mulliganPlayer = player;
  mulliganSelected = new Set();

  // AI (p2 in AI mode): ÏûêÎèô Î©ÄÎ¶¨Í±¥
  if (gameMode === 'ai' && player === 'p2') {
    aiMulligan();
    // Î©ÄÎ¶¨Í±¥ ÏôÑÎ£å ‚Üí Í≤åÏûÑ ÏãúÏûë
    addLog('ÏñëÏ∏° Î©ÄÎ¶¨Í±¥ ÏôÑÎ£å!');
    startTurn('p1');
    return;
  }

  const p = gameState[player];
  const screen = document.getElementById('mulligan-screen');
  const title = document.getElementById('mulligan-title');
  const container = document.getElementById('mulligan-cards');

  if (gameMode === 'pvp') {
    title.textContent = `${player === 'p1' ? 'ÌîåÎ†àÏù¥Ïñ¥ 1' : 'ÌîåÎ†àÏù¥Ïñ¥ 2'} - ÍµêÌôòÌï† Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî`;
  } else {
    title.textContent = 'ÍµêÌôòÌï† Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî';
  }

  container.innerHTML = '';
  p.hand.forEach((card, i) => {
    // ÎèôÏ†ÑÏùÄ Î©ÄÎ¶¨Í±¥ ÎåÄÏÉÅÏù¥ ÏïÑÎãò
    if (card.id === 'coin') return;
    const div = document.createElement('div');
    div.className = 'mulligan-card';
    div.dataset.index = i;
    const statsText = card.type === 'minion' ? `${card.attack}/${card.health}` : 'Ï£ºÎ¨∏';
    div.innerHTML = `
      <div class="m-cost">${card.cost}</div>
      <div class="m-emoji">${card.emoji}</div>
      <div class="m-name">${card.name}</div>
      <div class="m-stats">${statsText}</div>
    `;
    div.onclick = () => {
      const idx = parseInt(div.dataset.index);
      if (mulliganSelected.has(idx)) {
        mulliganSelected.delete(idx);
        div.classList.remove('selected');
      } else {
        mulliganSelected.add(idx);
        div.classList.add('selected');
      }
      playSound('click');
    };
    container.appendChild(div);
  });

  screen.style.display = 'flex';
}

function confirmMulligan() {
  const p = gameState[mulliganPlayer];
  playSound('click');

  if (mulliganSelected.size > 0) {
    // ÏÑ†ÌÉùÎêú Ïπ¥ÎìúÎ•º Îç±Ïóê ÎÑ£Í≥† ÏÉàÎ°ú ÎΩëÍ∏∞
    const selectedIndices = [...mulliganSelected].sort((a, b) => b - a); // Ïó≠ÏàúÏúºÎ°ú Ï†úÍ±∞
    const cardsToReturn = selectedIndices.map(i => p.hand[i]);
    selectedIndices.forEach(i => p.hand.splice(i, 1));

    // Îç±Ïóê ÏÑûÏñ¥ÎÑ£Í∏∞
    cardsToReturn.forEach(card => {
      p.deck.push(card);
    });
    // Îç± ÏÖîÌîå
    for (let i = p.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [p.deck[i], p.deck[j]] = [p.deck[j], p.deck[i]];
    }

    // Í∞ôÏùÄ ÏàòÎßåÌÅº ÎìúÎ°úÏö∞
    for (let i = 0; i < cardsToReturn.length; i++) {
      drawCard(mulliganPlayer);
    }

    addLog(`${gameMode === 'pvp' ? (mulliganPlayer === 'p1' ? 'P1' : 'P2') : 'ÌîåÎ†àÏù¥Ïñ¥'}: ${cardsToReturn.length}Ïû• ÍµêÌôò!`);
  } else {
    addLog(`${gameMode === 'pvp' ? (mulliganPlayer === 'p1' ? 'P1' : 'P2') : 'ÌîåÎ†àÏù¥Ïñ¥'}: ÍµêÌôò ÏóÜÏù¥ Ïú†ÏßÄ!`);
  }

  document.getElementById('mulligan-screen').style.display = 'none';

  // Îã§Ïùå Îã®Í≥Ñ Í≤∞Ï†ï
  if (mulliganPlayer === 'p1') {
    if (gameMode === 'pvp') {
      // PVP: P2ÏóêÍ≤å ÎÑòÍ∏∞Í∏∞ Ï†ÑÏóê Ï†ÑÌôò ÏïàÎÇ¥
      showMulliganTransition();
    } else {
      // AI: P2 ÏûêÎèô Î©ÄÎ¶¨Í±¥
      startMulligan('p2');
    }
  } else {
    // Î©ÄÎ¶¨Í±¥ ÏôÑÎ£å ‚Üí Í≤åÏûÑ ÏãúÏûë
    addLog('ÏñëÏ∏° Î©ÄÎ¶¨Í±¥ ÏôÑÎ£å!');
    startTurn('p1');
  }
}

function showMulliganTransition() {
  const overlay = document.getElementById('turn-transition');
  document.getElementById('transition-text').textContent = 'ÌîåÎ†àÏù¥Ïñ¥ 2Ïùò Î©ÄÎ¶¨Í±¥ Ï∞®Î°Ä';
  overlay.style.display = 'flex';
  // Í∏∞Ï°¥ Î≤ÑÌäºÏùò onclickÏùÑ ÏûÑÏãú Î≥ÄÍ≤Ω
  const btn = overlay.querySelector('button');
  btn.onclick = () => {
    overlay.style.display = 'none';
    btn.onclick = () => confirmTurnTransition(); // ÏõêÎ≥µ
    startMulligan('p2');
  };
}

function aiMulligan() {
  const p = gameState.p2;
  const toReturn = [];

  // AI: 4ÏΩî Ïù¥ÏÉÅ Ïπ¥ÎìúÎ•º ÍµêÌôò (ÎèôÏ†Ñ Ï†úÏô∏)
  for (let i = p.hand.length - 1; i >= 0; i--) {
    if (p.hand[i].id === 'coin') continue;
    if (p.hand[i].cost >= 4) {
      toReturn.push(p.hand[i]);
      p.hand.splice(i, 1);
    }
  }

  if (toReturn.length > 0) {
    toReturn.forEach(card => p.deck.push(card));
    // Îç± ÏÖîÌîå
    for (let i = p.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [p.deck[i], p.deck[j]] = [p.deck[j], p.deck[i]];
    }
    for (let i = 0; i < toReturn.length; i++) {
      drawCard('p2');
    }
    addLog(`ÏÉÅÎåÄ: ${toReturn.length}Ïû• ÍµêÌôò!`);
  } else {
    addLog(`ÏÉÅÎåÄ: ÍµêÌôò ÏóÜÏù¥ Ïú†ÏßÄ!`);
  }
}

let lastDrawnUid = null;
let lastSummonedUid = null;
let isAttacking = false;

function drawCard(player) {
  const p = gameState[player];
  if (p.deck.length === 0) {
    // Fatigue damage
    p.fatigue = (p.fatigue || 0) + 1;
    p.hp -= p.fatigue;
    showHeroFloatingText(player, `-${p.fatigue}`, 'damage');
    addLog(`${getFactionName(p.faction)}: Îç± ÏÜåÏßÑ! ${p.fatigue} ÌîºÎ°ú Îç∞ÎØ∏ÏßÄ!`);
    checkGameOver();
    return;
  }
  if (p.hand.length >= 10) {
    const burned = p.deck.pop();
    addLog(`${burned.name} Ïπ¥ÎìúÍ∞Ä ÏÜêÏù¥ Í∞ÄÎìù Ï∞®ÏÑú Î∂àÌÉîÏäµÎãàÎã§!`);
    return;
  }
  const drawn = p.deck.pop();
  lastDrawnUid = drawn.uid;
  if (gameState.stats) gameState.stats[player].cardsDrawn++;
  if (gameState.turn > 0) playSound('draw');
  p.hand.push(drawn);
}

function startTurn(player) {
  const p = gameState[player];
  gameState.currentPlayer = player;
  isAttacking = false;
  if (gameState.turn === 0) gameState.turn = 1;

  // Increase mana
  if (p.maxMana < 10) p.maxMana++;
  p.mana = p.maxMana;

  // Reset hero power
  p.heroPowerUsed = false;

  // Reset minion attacks
  p.field.forEach(m => {
    m.canAttack = true;
    m.attacksThisTurn = 0;
    m.summonedThisTurn = false;
  });

  // Draw
  drawCard(player);

  // ÌîºÎ°ú Îç∞ÎØ∏ÏßÄÎ°ú Í≤åÏûÑ Ïò§Î≤Ñ Ïãú Ïù¥ÌõÑ Î°úÏßÅ Ï§ëÎã®
  if (gameState.gameOver) { render(); return; }

  clearSelection();
  render();
}

function endTurn() {
  if (gameState.gameOver) return;
  playSound('endturn');

  const current = gameState.currentPlayer;
  const next = current === 'p1' ? 'p2' : 'p1';

  if (current === 'p1' && next === 'p2') {
    // nothing special
  } else {
    gameState.turn++;
  }

  clearSelection();

  if (gameMode === 'pvp') {
    showTurnTransition(next);
  } else {
    startTurn(next);
    if (next === 'p2') {
      // AI turn
      setTimeout(() => aiTurn(), 500);
    }
  }
}

// ===== CARD PLAYING =====
function playCard(cardIndex) {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  if (gameMode === 'ai' && player === 'p2') return; // AI controls p2

  const p = gameState[player];
  const card = p.hand[cardIndex];

  if (!card) return;
  if (card.cost > p.mana) { playSound('error'); return; }

  if (card.type === 'minion') {
    if (p.field.length >= 7) {
      playSound('error');
      addLog('ÌïÑÎìúÍ∞Ä Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§!');
      return;
    }

    // Check if this minion has a targeted battlecry
    if (card.battlecry_target) {
      const opp = player === 'p1' ? 'p2' : 'p1';
      const targets = gameState[opp].field;
      if (targets.length > 0) {
        // Need to select a target
        battlecryTarget = { cardIndex, card, player };
        highlightTargets(card.battlecry_target, player);
        document.getElementById('cancel-target-btn').style.display = 'block';
        return;
      }
    }

    summonMinion(player, card, cardIndex);

  } else if (card.type === 'spell') {
    if (card.target === 'none') {
      // No target needed
      castSpell(player, card, cardIndex, null, null);
    } else {
      // Need to select target
      targetingSpell = { cardIndex, card, player };
      highlightTargets(card.target, player);
      document.getElementById('cancel-target-btn').style.display = 'block';
    }
  }
}

function summonMinion(player, card, cardIndex) {
  const p = gameState[player];

  p.mana -= card.cost;
  p.hand.splice(cardIndex, 1);

  const minion = {
    ...card,
    uid: card.uid,
    currentHealth: card.health,
    maxHealth: card.health,
    currentAttack: card.attack,
    canAttack: card.keywords.includes('rush'),
    summonedThisTurn: true,
    attacksThisTurn: 0,
  };

  p.field.push(minion);
  lastSummonedUid = minion.uid;
  gameState.stats[player].minionsPlayed++;
  addLog(`${card.name} ÏÜåÌôò! (${card.attack}/${card.health})`);
  playSound('summon');

  // Execute battlecry (battlecry_targetÏù¥ ÏûàÎäî Ïπ¥ÎìúÎäî executeBattlecry/AIÏóêÏÑú Î≥ÑÎèÑ Ï≤òÎ¶¨)
  if (card.battlecry && !card.battlecry_target && !card.battlecry_damage) {
    const isAI = gameMode === 'ai' && player === 'p2';
    const executeBattlecryEffect = () => {
      card.battlecry(gameState, player);
      triggerBattlecryFlash();
      const isHealBattlecry = card.desc.includes('ÌöåÎ≥µ');
      playSound(isHealBattlecry ? 'buff' : 'debuff');
      checkGameOver();
      render();
    };
    if (isAI) {
      // AIÎäî ÎèôÍ∏∞ Î£®ÌîÑÏù¥ÎØÄÎ°ú Ï¶âÏãú Ïã§ÌñâÌïòÏó¨ ÏÉÅÌÉú ÏùºÏπò Î≥¥Ïû•
      executeBattlecryEffect();
    } else {
      // ÌîåÎ†àÏù¥Ïñ¥Îäî ÏÜåÌôò ‚Üí Ï†ÑÌà¨ Ìï®ÏÑ± ÎîúÎ†àÏù¥ Ïó∞Ï∂ú
      setTimeout(executeBattlecryEffect, 300);
    }
  } else {
    checkGameOver();
    render();
  }
}

function executeBattlecry(targetMinion) {
  if (!battlecryTarget) return;

  const { cardIndex, card, player } = battlecryTarget;
  const p = gameState[player];
  const opp = player === 'p1' ? 'p2' : 'p1';

  // Summon first
  summonMinion(player, card, cardIndex);

  // Then deal battlecry damage (ÎîúÎ†àÏù¥)
  setTimeout(() => {
    triggerBattlecryFlash();
    playSound('debuff');
    if (card.battlecry_damage) {
      targetMinion.currentHealth -= card.battlecry_damage;
      addLog(`${card.name}Ïùò Ï†ÑÌà¨ Ìï®ÏÑ±! ${targetMinion.name}ÏóêÍ≤å ${card.battlecry_damage} Îç∞ÎØ∏ÏßÄ!`);
      showFloatingText(targetMinion.uid, `-${card.battlecry_damage}`, 'damage');

      // Remove dead minions
      gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
    }

    battlecryTarget = null;
    document.getElementById('cancel-target-btn').style.display = 'none';
    checkGameOver();
    render();
  }, 300);
}

function castSpell(player, card, cardIndex, targetType, target) {
  const p = gameState[player];
  const opp = player === 'p1' ? 'p2' : 'p1';

  p.mana -= card.cost;
  p.hand.splice(cardIndex, 1);

  gameState.stats[player].spellsCast++;
  addLog(`${card.name} ÏãúÏ†Ñ!`);
  // Ï£ºÎ¨∏ Ï¢ÖÎ•òÏóê Îî∞Î•∏ Ìö®Í≥ºÏùå (ÏΩîÏù∏ÏùÄ ÏûêÏ≤¥ ÏÇ¨Ïö¥Îìú ÏÇ¨Ïö©)
  if (card.effect !== 'coin') {
    const isBuffSpell = card.effect === 'buff' || card.effect === 'buff_atk' || card.effect === 'heal';
    playSound(isBuffSpell ? 'buff' : 'debuff');
  }

  switch(card.effect) {
    case 'damage':
      if (target === 'hero') {
        gameState[opp].hp -= card.value;
        gameState.stats[player].totalDamage += card.value;
        addLog(`Ï†Å ÏòÅÏõÖÏóêÍ≤å ${card.value} Îç∞ÎØ∏ÏßÄ!`);
        showHeroFloatingText(opp, `-${card.value}`, 'damage');
      } else if (target && target.uid) {
        target.currentHealth -= card.value;
        gameState.stats[player].totalDamage += card.value;
        addLog(`${target.name}ÏóêÍ≤å ${card.value} Îç∞ÎØ∏ÏßÄ!`);
        showFloatingText(target.uid, `-${card.value}`, 'damage');
        // Check if target has poison - doesn't apply to spells
        gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
      }
      break;
    case 'heal':
      if (target === 'hero') {
        const healed = Math.min(card.value, 30 - gameState[player].hp);
        gameState[player].hp = Math.min(30, gameState[player].hp + card.value);
        addLog(`ÏòÅÏõÖ Ï≤¥Î†• ${healed} ÌöåÎ≥µ!`);
        showHeroFloatingText(player, `+${healed}`, 'heal');
      } else if (target && target.uid) {
        const healed = Math.min(card.value, target.maxHealth - target.currentHealth);
        target.currentHealth = Math.min(target.maxHealth, target.currentHealth + card.value);
        addLog(`${target.name} Ï≤¥Î†• ${healed} ÌöåÎ≥µ!`);
        showFloatingText(target.uid, `+${healed}`, 'heal');
      }
      break;
    case 'aoe_damage':
      gameState[opp].field.forEach(m => {
        m.currentHealth -= card.value;
        gameState.stats[player].totalDamage += card.value;
        showFloatingText(m.uid, `-${card.value}`, 'damage');
      });
      gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
      addLog(`Ï†Å ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ÏóêÍ≤å ${card.value} Îç∞ÎØ∏ÏßÄ!`);
      break;
    case 'buff':
      if (target && target.uid) {
        target.currentAttack += card.value;
        target.currentHealth += card.value;
        target.maxHealth += card.value;
        addLog(`${target.name}ÏóêÍ≤å +${card.value}/+${card.value} Í∞ïÌôî!`);
        showFloatingText(target.uid, `+${card.value}/+${card.value}`, 'heal');
      }
      break;
    case 'buff_atk':
      if (target && target.uid) {
        target.currentAttack += card.value;
        target.currentHealth += 1;
        target.maxHealth += 1;
        addLog(`${target.name}ÏóêÍ≤å +${card.value}/+1 Í∞ïÌôî!`);
        showFloatingText(target.uid, `+${card.value}/+1`, 'heal');
      }
      break;
    case 'coin':
      p.mana = Math.min(10, p.mana + 1);
      playSound('coin');
      addLog('ÎßàÎÇò 1 ÌöçÎìù!');
      break;
  }

  targetingSpell = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
  checkGameOver();
  render();
}

// ===== COMBAT =====
function selectAttacker(minion) {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  if (gameMode === 'ai' && player === 'p2') return;

  const p = gameState[player];
  if (!p.field.includes(minion)) return;

  if (!minion.canAttack || minion.attacksThisTurn > 0) return;
  if (minion.summonedThisTurn && !minion.keywords.includes('rush')) return;

  clearSelection();
  selectedAttacker = minion;
  // Í≥µÍ≤© ÌôîÏÇ¥Ìëú ÏãúÏûëÏ†ê ÏÑ§Ï†ï
  const minionEl = document.querySelector(`[data-uid="${minion.uid}"]`);
  if (minionEl) {
    const rect = minionEl.getBoundingClientRect();
    attackArrowStart = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    showAttackArrow(attackArrowStart.x, attackArrowStart.y, attackArrowStart.x, attackArrowStart.y);
  }
  render();
}

function attackTarget(target, targetPlayer) {
  if (!selectedAttacker || gameState.gameOver) return;
  if (isAttacking) return;
  hideAttackArrow();

  const player = gameState.currentPlayer;
  const opp = player === 'p1' ? 'p2' : 'p1';

  if (targetPlayer !== opp) return;

  // Check taunt
  const hasTaunt = gameState[opp].field.some(m => m.keywords.includes('taunt'));
  if (hasTaunt && target !== 'hero' && !target.keywords.includes('taunt')) {
    playSound('taunt');
    addLog('ÎèÑÎ∞ú ÎØ∏ÎãàÏñ∏ÏùÑ Î®ºÏ†Ä Í≥µÍ≤©Ìï¥Ïïº Ìï©ÎãàÎã§!');
    return;
  }
  if (hasTaunt && target === 'hero') {
    playSound('taunt');
    addLog('ÎèÑÎ∞ú ÎØ∏ÎãàÏñ∏ÏùÑ Î®ºÏ†Ä Í≥µÍ≤©Ìï¥Ïïº Ìï©ÎãàÎã§!');
    return;
  }

  // Rush minions can't attack hero on summon turn
  if (selectedAttacker.summonedThisTurn && selectedAttacker.keywords.includes('rush') && target === 'hero') {
    addLog('ÎèåÏßÑ ÎØ∏ÎãàÏñ∏ÏùÄ ÏÜåÌôòÎêú ÌÑ¥Ïóê ÏòÅÏõÖÏùÑ Í≥µÍ≤©Ìï† Ïàò ÏóÜÏäµÎãàÎã§!');
    return;
  }

  // Ïã§Ï†ú Í≥µÍ≤© Ï≤òÎ¶¨ Ìï®Ïàò
  function processAttack() {
    if (gameState.gameOver) { isAttacking = false; clearSelection(); return; }
    if (target === 'hero') {
      playSound('attack');
      const heroEl = document.getElementById(opp === 'p1' ? 'my-hero' : 'opponent-hero');
      if (heroEl) heroEl.classList.add('hero-hit');
      setTimeout(() => { if (heroEl) heroEl.classList.remove('hero-hit'); }, 300);

      gameState[opp].hp -= selectedAttacker.currentAttack;
      gameState.stats[player].totalDamage += selectedAttacker.currentAttack;
      addLog(`${selectedAttacker.name}Ïù¥(Í∞Ä) Ï†Å ÏòÅÏõÖÏùÑ Í≥µÍ≤©! ${selectedAttacker.currentAttack} Îç∞ÎØ∏ÏßÄ!`);
      showHeroFloatingText(opp, `-${selectedAttacker.currentAttack}`, 'damage');

      if (selectedAttacker.keywords.includes('lifesteal')) {
        const healed = Math.min(selectedAttacker.currentAttack, 30 - gameState[player].hp);
        gameState[player].hp = Math.min(30, gameState[player].hp + selectedAttacker.currentAttack);
        addLog(`ÏÉùÎ™ÖÎ†• Ìù°Ïàò! ${healed} ÌöåÎ≥µ!`);
      }

      selectedAttacker.canAttack = false;
      selectedAttacker.attacksThisTurn++;
    } else {
      const attacker = selectedAttacker;
      playSound('attack');
      addLog(`${attacker.name}Ïù¥(Í∞Ä) ${target.name}ÏùÑ(Î•º) Í≥µÍ≤©!`);

      target.currentHealth -= attacker.currentAttack;
      attacker.currentHealth -= target.currentAttack;
      gameState.stats[player].totalDamage += attacker.currentAttack;
      gameState.stats[opp].totalDamage += target.currentAttack;

      showFloatingText(target.uid, `-${attacker.currentAttack}`, 'damage');
      showFloatingText(attacker.uid, `-${target.currentAttack}`, 'damage');

      if (attacker.keywords.includes('poison') && target.currentHealth > 0) {
        target.currentHealth = 0;
        addLog(`${target.name}Ïù¥(Í∞Ä) ÎèÖÏóê ÏùòÌï¥ Ï¶âÏÇ¨!`);
      }
      if (target.keywords.includes('poison') && attacker.currentHealth > 0) {
        attacker.currentHealth = 0;
        addLog(`${attacker.name}Ïù¥(Í∞Ä) ÎèÖÏóê ÏùòÌï¥ Ï¶âÏÇ¨!`);
      }

      if (attacker.keywords.includes('lifesteal')) {
        const healed = Math.min(attacker.currentAttack, 30 - gameState[player].hp);
        gameState[player].hp = Math.min(30, gameState[player].hp + attacker.currentAttack);
        if (healed > 0) addLog(`ÏÉùÎ™ÖÎ†• Ìù°Ïàò! ${healed} ÌöåÎ≥µ!`);
      }

      // ÏÇ¨Îßù Ï≤òÎ¶¨ Ï†ÑÏóê Í≥µÍ≤© ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      attacker.canAttack = false;
      attacker.attacksThisTurn++;

      const deadCount = gameState[player].field.filter(m => m.currentHealth <= 0).length +
                        gameState[opp].field.filter(m => m.currentHealth <= 0).length;
      if (deadCount > 0) setTimeout(() => playSound('death'), 100);
      gameState[player].field = gameState[player].field.filter(m => m.currentHealth > 0);
      gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
    }

    isAttacking = false;
    clearSelection();
    checkGameOver();
    render();
  }

  // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌõÑ Í≥µÍ≤© Ï≤òÎ¶¨
  isAttacking = true;
  const attackerUid = selectedAttacker.uid;
  const attackerEl = document.querySelector(`[data-uid="${attackerUid}"]`);
  const isPlayerTop = player === 'p2';
  if (attackerEl) {
    attackerEl.classList.add(isPlayerTop ? 'attack-anim-down' : 'attack-anim');
  }
  setTimeout(processAttack, 250);
}

function targetHero(side) {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  const opp = player === 'p1' ? 'p2' : 'p1';

  // If selecting target for a spell
  // render()ÏóêÏÑú Î∑∞ Í∏∞Ï§ÄÏúºÎ°ú my/oppÎ•º Îß§ÌïëÌïòÎØÄÎ°ú, DOMÏùò 'opponent'ÏùÄ Ìï≠ÏÉÅ Ï†Å, 'mine'ÏùÄ Ìï≠ÏÉÅ ÏïÑÍµ∞
  if (targetingSpell) {
    const { card, cardIndex } = targetingSpell;
    if (card.target === 'enemy_any' && side === 'opponent') {
      castSpell(player, card, cardIndex, 'enemy_hero', 'hero');
    } else if (card.target === 'friendly_any' && side === 'mine') {
      castSpell(player, card, cardIndex, 'friendly_hero', 'hero');
    }
    return;
  }

  // If attacking with a minion
  if (selectedAttacker) {
    const targetPlayer = side === 'opponent' ? (player === 'p1' ? 'p2' : 'p1') : player;
    if (targetPlayer === opp) {
      attackTarget('hero', opp);
    }
  }
}

// ===== HERO POWER =====
function useHeroPower() {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  if (gameMode === 'ai' && player === 'p2') return;

  const p = gameState[player];
  const opp = player === 'p1' ? 'p2' : 'p1';

  if (p.heroPowerUsed || p.mana < 2) return;

  p.mana -= 2;
  p.heroPowerUsed = true;
  gameState.stats[player].heroPowerUsed++;
  playSound('heropower');

  executeHeroPower(p, player, opp, false);

  checkGameOver();
  render();
}

function executeHeroPower(p, player, opp, isAI) {
  const faction = p.faction;
  const oppState = gameState[opp];

  if (faction === 'human') {
    // ÏÑ±Ïä§Îü¨Ïö¥ Îπõ: ÏòÅÏõÖ Ï≤¥Î†• 3 ÌöåÎ≥µ
    const healed = Math.min(3, 30 - p.hp);
    p.hp = Math.min(30, p.hp + 3);
    showHeroFloatingText(player, `+${healed}`, 'heal');
    addLog(`ÏÑ±Ïä§Îü¨Ïö¥ Îπõ! ÏòÅÏõÖ Ï≤¥Î†• ${healed} ÌöåÎ≥µ! (${p.hp}/30)`);

  } else if (faction === 'demon') {
    // ÏÉùÎ™Ö Ï∞©Ï∑®: ÏûêÌï¥ 2ÎéÄ + Ïπ¥Îìú 1Ïû• ÎìúÎ°úÏö∞
    p.hp -= 2;
    gameState.stats[player].totalDamage += 0; // ÏûêÌï¥Îäî ÌÜµÍ≥Ñ ÎØ∏Ìè¨Ìï®
    showHeroFloatingText(player, `-2`, 'damage');
    addLog(`ÏÉùÎ™Ö Ï∞©Ï∑®! ÏûêÌï¥ 2 Îç∞ÎØ∏ÏßÄ! (${p.hp}/30)`);
    checkGameOver();
    if (!gameState.gameOver) {
      drawCard(player);
      addLog(`ÏÉùÎ™Ö Ï∞©Ï∑®! Ïπ¥Îìú 1Ïû• ÎìúÎ°úÏö∞!`);
    }

  } else if (faction === 'elf') {
    // Îã¨Îπõ ÌôîÏÇ¥: Ï†Å ÎØ∏ÎãàÏñ∏ ÌïòÎÇòÏóêÍ≤å 1ÎéÄ (ÏóÜÏúºÎ©¥ Ï†Å ÏòÅÏõÖ 1ÎéÄ)
    if (oppState.field.length > 0) {
      if (isAI) {
        // AI: Ï≤¥Î†• 1Ïù∏ ÎØ∏ÎãàÏñ∏ Ïö∞ÏÑ†, ÏóÜÏúºÎ©¥ Í≥µÍ≤©Î†• ÎÜíÏùÄ ÎØ∏ÎãàÏñ∏
        const oneHp = oppState.field.find(m => m.currentHealth === 1);
        const target = oneHp || [...oppState.field].sort((a, b) => b.currentAttack - a.currentAttack)[0];
        target.currentHealth -= 1;
        gameState.stats[player].totalDamage += 1;
        addLog(`Îã¨Îπõ ÌôîÏÇ¥! ${target.name}ÏóêÍ≤å 1 Îç∞ÎØ∏ÏßÄ!`);
        showFloatingText(target.uid, `-1`, 'damage');
        oppState.field = oppState.field.filter(m => m.currentHealth > 0);
      } else {
        // ÌîåÎ†àÏù¥Ïñ¥: ÏûêÎèôÏúºÎ°ú Ï≤¥Î†• Í∞ÄÏû• ÎÇÆÏùÄ ÎØ∏ÎãàÏñ∏ ÌÉÄÍ≤©
        const target = [...oppState.field].sort((a, b) => a.currentHealth - b.currentHealth)[0];
        target.currentHealth -= 1;
        gameState.stats[player].totalDamage += 1;
        addLog(`Îã¨Îπõ ÌôîÏÇ¥! ${target.name}ÏóêÍ≤å 1 Îç∞ÎØ∏ÏßÄ!`);
        showFloatingText(target.uid, `-1`, 'damage');
        oppState.field = oppState.field.filter(m => m.currentHealth > 0);
      }
    } else {
      oppState.hp -= 1;
      gameState.stats[player].totalDamage += 1;
      showHeroFloatingText(opp, `-1`, 'damage');
      addLog(`Îã¨Îπõ ÌôîÏÇ¥! Ï†Å ÏòÅÏõÖÏóêÍ≤å 1 Îç∞ÎØ∏ÏßÄ! (${oppState.hp}/30)`);
    }

  } else if (faction === 'druid') {
    // ÏïºÏÉùÏùò Î∂ÄÎ¶Ñ: 1/1 Îã§ÎûåÏ•ê ÏÜåÌôò (ÎèåÏßÑ ÏóÜÏùå)
    if (p.field.length < 7) {
      const squirrel = {
        id: 'squirrel_token', name: 'Îã§ÎûåÏ•ê', type: 'minion', cost: 0,
        attack: 1, health: 1, emoji: 'üêøÔ∏è', desc: '',
        keywords: [],
        uid: Date.now() + Math.random(),
        currentHealth: 1, maxHealth: 1, currentAttack: 1,
        canAttack: false, summonedThisTurn: true, attacksThisTurn: 0,
      };
      p.field.push(squirrel);
      lastSummonedUid = squirrel.uid;
      addLog(`Îã§ÎûåÏ•ê ÏÜåÌôò! (1/1)`);
      playSound('summon');
    } else {
      addLog(`ÌïÑÎìúÍ∞Ä Í∞ÄÎìù Ï∞®ÏÑú Îã§ÎûåÏ•êÎ•º ÏÜåÌôòÌï† Ïàò ÏóÜÏäµÎãàÎã§!`);
    }

  } else if (faction === 'dwarf') {
    // Ïû•Í∞ë Í∞ïÌôî: ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ +1 Ï≤¥Î†•, ÏóÜÏúºÎ©¥ ÏòÅÏõÖ 2 ÌöåÎ≥µ
    if (p.field.length > 0) {
      p.field.forEach(m => {
        m.currentHealth += 1;
        m.maxHealth += 1;
        showFloatingText(m.uid, `+1`, 'heal');
      });
      addLog(`Ïû•Í∞ë Í∞ïÌôî! ÏïÑÍµ∞ ÎØ∏ÎãàÏñ∏ Ï†ÑÏ≤¥ Ï≤¥Î†• +1!`);
      playSound('buff');
    } else {
      p.hp = Math.min(30, p.hp + 2);
      showHeroFloatingText(player, `+2`, 'heal');
      addLog(`Ïû•Í∞ë Í∞ïÌôî! ÎØ∏ÎãàÏñ∏Ïù¥ ÏóÜÏñ¥ ÏòÅÏõÖ Ï≤¥Î†• 2 ÌöåÎ≥µ! (${p.hp}/30)`);
    }
  }
}

// ===== TARGETING =====
function highlightTargets(targetType, player) {
  const opp = player === 'p1' ? 'p2' : 'p1';
  render(); // re-render to show targeting state
}

function cancelTargeting() {
  targetingSpell = null;
  battlecryTarget = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
  clearSelection();
  render();
}

function clearSelection() {
  selectedAttacker = null;
  targetingSpell = null;
  battlecryTarget = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
  hideAttackArrow();
}

// ===== ATTACK ARROW =====
let attackArrowStart = null;

function showAttackArrow(x1, y1, x2, y2) {
  const svg = document.getElementById('attack-arrow');
  const line = document.getElementById('arrow-line');
  svg.style.display = 'block';
  line.setAttribute('x1', x1);
  line.setAttribute('y1', y1);
  line.setAttribute('x2', x2);
  line.setAttribute('y2', y2);
}

function hideAttackArrow() {
  document.getElementById('attack-arrow').style.display = 'none';
  attackArrowStart = null;
}

// ===== GAME OVER =====
function checkGameOver() {
  if (gameState.gameOver) return; // Ïù¥ÎØ∏ Í≤åÏûÑ Ïò§Î≤ÑÎ©¥ Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ
  if (gameState.p1.hp <= 0) {
    gameState.gameOver = true;
    gameState.winner = 'p2';
    setTimeout(() => showGameOver(), 500);
  } else if (gameState.p2.hp <= 0) {
    gameState.gameOver = true;
    gameState.winner = 'p1';
    setTimeout(() => showGameOver(), 500);
  }
}

function showGameOver() {
  const overlay = document.getElementById('game-over');
  const title = document.getElementById('game-over-title');
  const text = document.getElementById('game-over-text');
  const statsEl = document.getElementById('game-over-stats');

  if (gameMode === 'ai') {
    if (gameState.winner === 'p1') {
      title.textContent = 'ÏäπÎ¶¨!';
      title.style.color = '#f1c40f';
      text.textContent = 'Ï†Å ÏòÅÏõÖÏùÑ Ïì∞Îü¨Îú®Î†∏ÏäµÎãàÎã§!';
      playSound('victory');
    } else {
      title.textContent = 'Ìå®Î∞∞...';
      title.style.color = '#e74c3c';
      text.textContent = 'ÏòÅÏõÖÏù¥ Ïì∞Îü¨Ï°åÏäµÎãàÎã§...';
      playSound('defeat');
    }
  } else {
    const winFaction = gameState[gameState.winner].faction;
    title.textContent = `${getFactionName(winFaction)} ÏäπÎ¶¨!`;
    title.style.color = '#f1c40f';
    text.textContent = `${getFactionName(winFaction)} ÏßÑÏòÅÏù¥ ÏäπÎ¶¨ÌñàÏäµÎãàÎã§!`;
    playSound('victory');
  }

  // ÌÜµÍ≥Ñ ÌëúÏãú
  const s1 = gameState.stats.p1;
  const s2 = gameState.stats.p2;
  const p1Name = getFactionName(gameState.p1.faction);
  const p2Name = getFactionName(gameState.p2.faction);
  statsEl.innerHTML = `
    <div class="stats-turn-info">Ï¥ù ${gameState.turn} ÌÑ¥</div>
    <div class="stats-column">
      <h3>${getHeroEmoji(gameState.p1.faction)} ${p1Name}</h3>
      <div class="stat-row"><span>Ï¥ù Îç∞ÎØ∏ÏßÄ</span><span>${s1.totalDamage}</span></div>
      <div class="stat-row"><span>ÎØ∏ÎãàÏñ∏ ÏÜåÌôò</span><span>${s1.minionsPlayed}</span></div>
      <div class="stat-row"><span>Ï£ºÎ¨∏ ÏÇ¨Ïö©</span><span>${s1.spellsCast}</span></div>
      <div class="stat-row"><span>Ïπ¥Îìú ÎìúÎ°úÏö∞</span><span>${s1.cardsDrawn}</span></div>
      <div class="stat-row"><span>ÏòÅÏõÖ Îä•Î†•</span><span>${s1.heroPowerUsed}</span></div>
    </div>
    <div class="stats-column">
      <h3>${getHeroEmoji(gameState.p2.faction)} ${p2Name}</h3>
      <div class="stat-row"><span>Ï¥ù Îç∞ÎØ∏ÏßÄ</span><span>${s2.totalDamage}</span></div>
      <div class="stat-row"><span>ÎØ∏ÎãàÏñ∏ ÏÜåÌôò</span><span>${s2.minionsPlayed}</span></div>
      <div class="stat-row"><span>Ï£ºÎ¨∏ ÏÇ¨Ïö©</span><span>${s2.spellsCast}</span></div>
      <div class="stat-row"><span>Ïπ¥Îìú ÎìúÎ°úÏö∞</span><span>${s2.cardsDrawn}</span></div>
      <div class="stat-row"><span>ÏòÅÏõÖ Îä•Î†•</span><span>${s2.heroPowerUsed}</span></div>
    </div>
  `;

  // ÌÉÄÏù¥ÌãÄ Ïï†ÎãàÎ©îÏù¥ÏÖò
  title.className = '';
  void title.offsetWidth;
  title.classList.add('animate-result');

  overlay.style.display = 'flex';
  stopBGM();

  // ÏäπÎ¶¨/Ìå®Î∞∞ BGM (AI: P1ÏäπÎ¶¨Ïãú victory, PVP: Ìï≠ÏÉÅ victory)
  const playVictory = gameMode !== 'ai' || gameState.winner === 'p1';
  setTimeout(() => playBGM(playVictory ? 'victory' : 'defeat'), 600);
}

// ===== PVP TURN TRANSITION =====
let pendingNextPlayer = null;

function showTurnTransition(nextPlayer) {
  pendingNextPlayer = nextPlayer;
  const overlay = document.getElementById('turn-transition');
  const text = document.getElementById('transition-text');
  const faction = gameState[nextPlayer].faction;
  text.textContent = `${getFactionName(faction)} ÌîåÎ†àÏù¥Ïñ¥ Ï∞®Î°Ä`;
  overlay.style.display = 'flex';
}

function confirmTurnTransition() {
  document.getElementById('turn-transition').style.display = 'none';
  if (pendingNextPlayer) {
    startTurn(pendingNextPlayer);
    pendingNextPlayer = null;
  }
}

// ===== AI =====
const AI_DELAY = 600; // Ïπ¥Îìú Í∞Ñ ÎîúÎ†àÏù¥(ms)

function aiTurn() {
  if (gameState.gameOver || gameState.currentPlayer !== 'p2') return;

  // 1Îã®Í≥Ñ: Ïπ¥Îìú ÌîåÎ†àÏù¥ (ÎîúÎ†àÏù¥ Ìè¨Ìï® ÏàúÏ∞® Ïã§Ìñâ)
  aiPlayNextCard();
}

function aiPlayNextCard() {
  if (gameState.gameOver) return;
  const p = gameState.p2;
  const opp = gameState.p1;

  const playable = p.hand
    .map((c, i) => ({card: c, index: i}))
    .filter(({card}) => card.cost <= p.mana)
    .sort((a, b) => b.card.cost - a.card.cost);

  if (playable.length === 0) {
    // Ïπ¥Îìú ÌîåÎ†àÏù¥ ÎÅù ‚Üí ÏòÅÏõÖ Îä•Î†• ‚Üí Í≥µÍ≤©
    setTimeout(() => aiUseHeroPower(), AI_DELAY);
    return;
  }

  const {card} = playable[0];
  if (card.cost > p.mana) {
    setTimeout(() => aiUseHeroPower(), AI_DELAY);
    return;
  }

  const prevHandSize = p.hand.length;
  let played = false;

  if (card.type === 'minion' && p.field.length < 7) {
    const ci = p.hand.findIndex(c => c.uid === card.uid);
    if (ci >= 0) {
      if (card.battlecry_target === 'enemy_minion' && opp.field.length > 0) {
        const target = opp.field.reduce((best, m) => {
          if (m.currentHealth <= card.battlecry_damage) return m;
          return best || m;
        }, null) || opp.field[0];
        summonMinion('p2', card, ci);
        if (target) {
          triggerBattlecryFlash();
          playSound('debuff');
          target.currentHealth -= card.battlecry_damage;
          gameState.stats.p2.totalDamage += card.battlecry_damage;
          addLog(`${card.name}Ïùò Ï†ÑÌà¨ Ìï®ÏÑ±! ${target.name}ÏóêÍ≤å ${card.battlecry_damage} Îç∞ÎØ∏ÏßÄ!`);
          showFloatingText(target.uid, `-${card.battlecry_damage}`, 'damage');
          opp.field = opp.field.filter(m => m.currentHealth > 0);
        }
      } else {
        summonMinion('p2', card, ci);
      }
      played = true;
    }
  } else if (card.type === 'spell') {
    const ci = p.hand.findIndex(c => c.uid === card.uid);
    if (ci >= 0) {
      if (card.effect !== 'coin') showAiActionBanner(`${card.emoji} ${card.name} ÏãúÏ†Ñ!`);

      if (card.effect === 'aoe_damage') {
        if (opp.field.length >= 2) { castSpell('p2', card, ci, null, null); played = true; }
      } else if (card.effect === 'damage') {
        if (card.target === 'enemy_minion' && opp.field.length > 0) {
          const target = [...opp.field].sort((a, b) => {
            if (a.currentHealth <= card.value && b.currentHealth > card.value) return -1;
            if (b.currentHealth <= card.value && a.currentHealth > card.value) return 1;
            return b.currentAttack - a.currentAttack;
          })[0];
          castSpell('p2', card, ci, 'minion', target); played = true;
        } else if (card.target === 'enemy_any') {
          const killable = opp.field.find(m => m.currentHealth <= card.value);
          if (killable) {
            castSpell('p2', card, ci, 'minion', killable);
          } else if (opp.hp <= card.value) {
            castSpell('p2', card, ci, 'hero', 'hero');
          } else if (opp.field.length > 0) {
            castSpell('p2', card, ci, 'minion', [...opp.field].sort((a, b) => b.currentAttack - a.currentAttack)[0]);
          } else {
            castSpell('p2', card, ci, 'hero', 'hero');
          }
          played = true;
        }
      } else if ((card.effect === 'buff' || card.effect === 'buff_atk') && p.field.length > 0) {
        const target = [...p.field].sort((a, b) => b.currentAttack - a.currentAttack)[0];
        castSpell('p2', card, ci, 'minion', target); played = true;
      } else if (card.effect === 'heal') {
        const damaged = [...p.field].filter(m => m.currentHealth < m.maxHealth)
          .sort((a, b) => (b.maxHealth - b.currentHealth) - (a.maxHealth - a.currentHealth));
        if (card.target === 'friendly_any') {
          if (damaged.length > 0 && (damaged[0].maxHealth - damaged[0].currentHealth) >= card.value) {
            castSpell('p2', card, ci, 'minion', damaged[0]); played = true;
          } else if (p.hp < 20) {
            castSpell('p2', card, ci, 'hero', 'hero'); played = true;
          }
        } else if (card.target === 'friendly_minion' && damaged.length > 0) {
          castSpell('p2', card, ci, 'minion', damaged[0]); played = true;
        }
      } else if (card.effect === 'coin') {
        const couldPlay = p.hand.some(c => c.id !== 'coin' && c.cost === p.mana + 1 &&
          (c.type !== 'minion' || p.field.length < 7));
        if (couldPlay) { castSpell('p2', card, ci, null, null); played = true; }
      }
    }
  }

  render();

  if (played && p.hand.length < prevHandSize) {
    // Îã§Ïùå Ïπ¥Îìú ÌîåÎ†àÏù¥ (ÎîúÎ†àÏù¥)
    setTimeout(() => aiPlayNextCard(), AI_DELAY);
  } else {
    // Îçî Ïù¥ÏÉÅ ÌîåÎ†àÏù¥ Î∂àÍ∞Ä ‚Üí ÏòÅÏõÖ Îä•Î†• ‚Üí Í≥µÍ≤©
    setTimeout(() => aiUseHeroPower(), AI_DELAY);
  }
}

function aiUseHeroPower() {
  if (gameState.gameOver) { aiStartAttack(); return; }
  const p = gameState.p2;

  if (!p.heroPowerUsed && p.mana >= 2) {
    const shouldUseHeroPower = !(p.faction === 'demon' && p.hp <= 5);
    if (shouldUseHeroPower) {
      showAiActionBanner(`‚ö° ${getHeroPowerName(p.faction)}!`);
      p.mana -= 2;
      p.heroPowerUsed = true;
      gameState.stats.p2.heroPowerUsed++;
      executeHeroPower(p, 'p2', 'p1', true);
      checkGameOver();
      render();
    }
  }

  setTimeout(() => aiStartAttack(), AI_DELAY);
}

function aiStartAttack() {
  if (gameState.gameOver) return;
  aiAttack();
}

function aiAttack() {
  if (gameState.gameOver) return;

  const p = gameState.p2;
  const opp = gameState.p1;

  const attackers = p.field.filter(m => {
    if (m.attacksThisTurn > 0) return false;
    if (m.summonedThisTurn && !m.keywords.includes('rush')) return false;
    return true;
  });

  let i = 0;
  function nextAttack() {
    if (i >= attackers.length || gameState.gameOver) {
      selectedAttacker = null;
      setTimeout(() => { if (!gameState.gameOver) endTurn(); }, 300);
      return;
    }

    const attacker = attackers[i];
    // Ïù¥ÎØ∏ Ï£ΩÏóàÏúºÎ©¥ Ïä§ÌÇµ
    if (attacker.currentHealth <= 0) { i++; nextAttack(); return; }

    i++;
    selectedAttacker = attacker;

    const hasTaunt = opp.field.some(m => m.keywords.includes('taunt'));
    let target = null;

    if (hasTaunt) {
      const tauntMinions = opp.field.filter(m => m.keywords.includes('taunt'));
      if (tauntMinions.length > 0) {
        target = tauntMinions.sort((a, b) => {
          const aTV = (a.currentHealth <= attacker.currentAttack ? a.currentAttack : 0);
          const bTV = (b.currentHealth <= attacker.currentAttack ? b.currentAttack : 0);
          return bTV - aTV;
        })[0];
      }
    }

    if (!target) {
      if (opp.hp <= attacker.currentAttack && !(attacker.summonedThisTurn && attacker.keywords.includes('rush'))) {
        target = 'hero';
      } else {
        const killable = opp.field.filter(m => m.currentHealth <= attacker.currentAttack)
          .sort((a, b) => b.currentAttack - a.currentAttack);
        if (killable.length > 0 && killable[0].currentAttack < attacker.currentHealth) {
          target = killable[0];
        } else if (attacker.summonedThisTurn && attacker.keywords.includes('rush')) {
          if (opp.field.length > 0) {
            target = [...opp.field].sort((a, b) => b.currentAttack - a.currentAttack)[0];
          }
        } else if (opp.field.length === 0 || attacker.currentAttack >= 3) {
          target = 'hero';
        } else if (opp.field.length > 0) {
          target = [...opp.field].sort((a, b) => b.currentAttack - a.currentAttack)[0];
        }
      }
    }

    if (target) {
      attackTarget(target, 'p1');
      // attackTargetÏù¥ 250ms ÌõÑ renderÌïòÎØÄÎ°ú Í∑∏ Îí§Ïóê Îã§Ïùå Í≥µÍ≤©
      setTimeout(nextAttack, 350);
    } else {
      // ÎèåÏßÑ ÎØ∏ÎãàÏñ∏Ïù¥ Í≥µÍ≤© ÎåÄÏÉÅ ÏóÜÎäî Í≤ΩÏö∞ Î°úÍ∑∏
      if (attacker.summonedThisTurn && attacker.keywords.includes('rush')) {
        addLog(`${attacker.name}: Í≥µÍ≤©Ìï† ÎåÄÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.`);
      }
      nextAttack();
    }
  }

  nextAttack();
}

// ===== RENDERING =====
function render() {
  if (!gameState) return;
  hideTooltip();

  const player = gameState.currentPlayer;
  const isP1View = gameMode === 'ai' || player === 'p1';

  const myKey = isP1View ? 'p1' : 'p2';
  const oppKey = isP1View ? 'p2' : 'p1';
  const my = gameState[myKey];
  const opp = gameState[oppKey];

  // Turn info
  document.getElementById('turn-info').textContent = `ÌÑ¥ ${gameState.turn}`;
  document.getElementById('game-mode-info').textContent =
    gameMode === 'ai' ? 'AI ÎåÄÏ†Ñ' : `2Ïù∏ ÎåÄÏ†Ñ - ${getFactionName(gameState[player].faction)} Ï∞®Î°Ä`;

  // Hero portraits
  const myHero = document.getElementById('my-hero');
  const oppHero = document.getElementById('opponent-hero');
  myHero.className = `hero-portrait ${getHeroClass(my.faction)}`;
  oppHero.className = `hero-portrait ${getHeroClass(opp.faction)}`;

  document.getElementById('my-hero-icon').textContent = getHeroEmoji(my.faction);
  document.getElementById('opponent-hero-icon').textContent = getHeroEmoji(opp.faction);
  document.getElementById('my-hp').textContent = my.hp;
  document.getElementById('opponent-hp').textContent = opp.hp;
  document.getElementById('my-name').textContent = getFactionName(my.faction);
  document.getElementById('opponent-name').textContent = getFactionName(opp.faction);

  // HP color
  document.getElementById('my-hp').style.background = my.hp <= 10 ? '#e74c3c' : '#c0392b';
  document.getElementById('opponent-hp').style.background = opp.hp <= 10 ? '#e74c3c' : '#c0392b';

  // Mana bars
  renderManaBar('my-mana-bar', my);
  renderManaBar('opponent-mana-bar', opp);

  // Deck counts
  document.getElementById('my-deck-count').textContent = `Îç±: ${my.deck.length}`;
  document.getElementById('opponent-deck-count').textContent = `Îç±: ${opp.deck.length}`;

  // Hero power buttons
  const myPowerBtn = document.getElementById('my-power-btn');
  const oppPowerBtn = document.getElementById('opponent-power-btn');

  const isMyTurn = (gameMode === 'ai' && player === 'p1' && myKey === 'p1') ||
                   (gameMode === 'pvp' && myKey === player);

  myPowerBtn.textContent = `${getHeroPowerName(my.faction)} (2)`;
  myPowerBtn.onmouseenter = (e) => showHeroPowerTooltip(my.faction, e);
  myPowerBtn.onmouseleave = () => hideTooltip();
  if (my.heroPowerUsed) {
    myPowerBtn.className = 'hero-power-btn used';
  } else if (my.mana < 2 || !isMyTurn) {
    myPowerBtn.className = 'hero-power-btn disabled';
  } else {
    myPowerBtn.className = 'hero-power-btn';
  }

  oppPowerBtn.textContent = `${getHeroPowerName(opp.faction)} (2)`;
  oppPowerBtn.onmouseenter = (e) => showHeroPowerTooltip(opp.faction, e);
  oppPowerBtn.onmouseleave = () => hideTooltip();
  oppPowerBtn.className = 'hero-power-btn disabled';

  // End turn button
  const endBtn = document.getElementById('end-turn-btn');
  if (gameMode === 'ai' && player === 'p2') {
    endBtn.className = 'end-turn-btn disabled';
    endBtn.textContent = 'ÏÉÅÎåÄ ÌÑ¥...';
  } else {
    endBtn.className = 'end-turn-btn';
    endBtn.textContent = 'ÌÑ¥ Ï¢ÖÎ£å';
  }

  // Opponent hero targetable? (ÎèÑÎ∞ú ÎØ∏ÎãàÏñ∏Ïù¥ ÏûàÏúºÎ©¥ Í≥µÍ≤© ÏÑ†ÌÉù Ïãú ÏòÅÏõÖ ÌÉÄÍ≤ü Î∂àÍ∞Ä)
  const oppHasTaunt = opp.field.some(m => m.keywords.includes('taunt'));
  if ((selectedAttacker && !oppHasTaunt) || (targetingSpell && (targetingSpell.card.target === 'enemy_any'))) {
    oppHero.classList.add('targetable');
  } else {
    oppHero.classList.remove('targetable');
  }

  // Render hands
  renderHand('my-hand', my, myKey, true);
  renderHand('opponent-hand', opp, oppKey, false);

  // Render fields
  renderField('my-field', my, myKey, true);
  renderField('opponent-field', opp, oppKey, false);

  // Log
  renderLog();
}

function renderManaBar(elementId, p) {
  const bar = document.getElementById(elementId);
  let html = '';
  for (let i = 0; i < p.maxMana; i++) {
    html += `<div class="mana-crystal ${i < p.mana ? 'filled' : ''}"></div>`;
  }
  html += `<span class="mana-text">${p.mana}/${p.maxMana}</span>`;
  bar.innerHTML = html;
}

function renderHand(elementId, p, playerKey, isMine) {
  const hand = document.getElementById(elementId);
  hand.innerHTML = '';

  if (!isMine) {
    // Show card backs
    const backCount = p.hand.length;
    const backOverlap = backCount > 8 ? Math.min(-10, -(backCount - 8) * 5) : 0;
    for (let i = 0; i < backCount; i++) {
      const back = document.createElement('div');
      back.className = `card-back card-back-${p.faction}`;
      back.setAttribute('data-emoji', 'üÇ†');
      if (backOverlap && i > 0) back.style.marginLeft = `${backOverlap}px`;
      hand.appendChild(back);
    }
    return;
  }

  const isCurrentPlayer = gameState.currentPlayer === playerKey;

  const count = p.hand.length;
  // 7Ïû• Ïù¥ÏÉÅÎ∂ÄÌÑ∞ ÏïÑÌÅ¨(Î∂ÄÏ±ÑÍº¥) Î∞∞Ïπò
  const arcEnabled = count >= 7;
  const maxAngle = arcEnabled ? Math.min((count - 5) * 2, 18) : 0;
  const arcHeight = arcEnabled ? Math.min((count - 5) * 5, 40) : 0;
  const overlapMargin = count > 8 ? Math.min(-10, -(count - 8) * 6) : 0;

  p.hand.forEach((card, i) => {
    const el = document.createElement('div');
    const factionClass = card.id === 'coin' ? 'coin-card' : getFactionClass(p.faction);
    const playable = isCurrentPlayer && card.cost <= p.mana && (card.type !== 'minion' || p.field.length < 7);

    const isDrawn = card.uid === lastDrawnUid;
    if (card.uid === lastDrawnUid) lastDrawnUid = null;
    el.className = `card in-hand ${factionClass} ${card.type === 'spell' ? 'spell-card' : ''} ${playable ? 'playable' : ''} ${isDrawn ? 'card-draw-anim' : ''}`;

    // ÏïÑÌÅ¨ Î∞∞Ïπò Í≥ÑÏÇ∞ (ÏïÑÌÅ¨ ÎπÑÌôúÏÑ± Ïãú Í∏∞Î≥∏Í∞í 0)
    let arcAngle = 0, arcY = 0;
    if (arcEnabled) {
      const center = (count - 1) / 2;
      const offset = i - center;
      const normalizedOffset = center > 0 ? offset / center : 0;
      arcAngle = normalizedOffset * maxAngle;
      arcY = normalizedOffset * normalizedOffset * arcHeight;
      el.style.transformOrigin = 'center bottom';
      if (overlapMargin && i > 0) el.style.marginLeft = `${overlapMargin}px`;
      el.style.zIndex = i;
    }

    // ÏµúÏ¢Ö ÏïÑÌÅ¨ ÏúÑÏπò Ï†ÅÏö© (ÎìúÎ°úÏö∞ Ïπ¥ÎìúÎäî Ï¥àÍ∏∞ ÏÉÅÌÉú ÌõÑ transition)
    const finalTransform = `rotate(${arcAngle}deg) translateY(${arcY}px)`;
    if (isDrawn) {
      // ÏúÑÏóêÏÑú ÎÇ†ÏïÑÏò§Îäî Ï¥àÍ∏∞ ÏÉÅÌÉú
      el.style.transform = `rotate(-10deg) translateY(-60px) scale(0.5)`;
      el.style.opacity = '0';
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          el.classList.remove('card-draw-anim');
          el.style.transition = 'opacity 0.3s ease-out, transform 0.4s ease-out';
          el.style.transform = finalTransform;
          el.style.opacity = '1';
        });
      });
    } else {
      el.style.transform = finalTransform;
    }

    el.innerHTML = `
      <div class="card-mana">${card.cost}</div>
      <div class="card-art">${card.emoji}</div>
      <div class="card-name">${card.name}</div>
      <div class="card-desc">${card.desc || ''}</div>
      ${card.type === 'minion' ? `
        <div class="card-stats">
          <div class="card-attack">${card.attack}</div>
          <div class="card-health">${card.health}</div>
        </div>
      ` : '<div class="card-stats"></div>'}
    `;

    if (isCurrentPlayer) {
      el.onclick = () => playCard(i);
    }

    // Tooltip on hover
    el.onmouseenter = (e) => showTooltip(card, e);
    el.onmouseleave = () => hideTooltip();

    hand.appendChild(el);
  });
}

function renderField(elementId, p, playerKey, isMine) {
  const field = document.getElementById(elementId);
  field.innerHTML = '';

  const currentPlayer = gameState.currentPlayer;
  const isMyTurn = currentPlayer === playerKey;
  const opp = playerKey === 'p1' ? 'p2' : 'p1';

  p.field.forEach(m => {
    const el = document.createElement('div');
    el.setAttribute('data-uid', m.uid);
    const factionClass = getFactionClass(p.faction);

    let canAtk = isMine && isMyTurn && m.attacksThisTurn === 0 &&
      (!m.summonedThisTurn || m.keywords.includes('rush'));

    // For AI mode, only P1 can control
    if (gameMode === 'ai' && playerKey === 'p2') canAtk = false;

    const isSelected = selectedAttacker && selectedAttacker.uid === m.uid;
    // ÎèÑÎ∞úÏù¥ ÏûàÏúºÎ©¥ ÎèÑÎ∞ú ÎØ∏ÎãàÏñ∏Îßå ÌÉÄÍ≤ü Í∞ÄÎä• (Ï£ºÎ¨∏ ÌÉÄÍ≤üÌåÖÏùÄ ÎèÑÎ∞ú Î¨¥Ïãú)
    const hasTauntOnField = !isMine && gameState[playerKey].field.some(x => x.keywords.includes('taunt'));
    const isTargetable = !isMine && (
      (selectedAttacker && (!hasTauntOnField || m.keywords.includes('taunt'))) ||
      targetingSpell || battlecryTarget
    );

    const summonAnim = (m.uid === lastSummonedUid) ? 'summon-anim' : '';
    if (m.uid === lastSummonedUid) lastSummonedUid = null;
    el.className = `field-minion ${factionClass} ${canAtk ? 'can-attack' : ''} ${m.keywords.includes('taunt') ? 'taunt' : ''} ${isSelected ? 'selected' : ''} ${isTargetable ? 'targetable' : ''} ${summonAnim}`;

    const keywordText = m.keywords.filter(k => k !== '').map(k => {
      switch(k) {
        case 'taunt': return 'ÎèÑÎ∞ú';
        case 'rush': return 'ÎèåÏßÑ';
        case 'poison': return 'ÎèÖ';
        case 'lifesteal': return 'Ìù°Ïàò';
        default: return k;
      }
    }).join(' ');

    const healthDamaged = m.currentHealth < m.maxHealth;

    el.innerHTML = `
      <div class="minion-art">${m.emoji}</div>
      <div class="minion-name">${m.name}</div>
      <div class="minion-keywords">${keywordText}</div>
      <div class="minion-stats">
        <div class="minion-attack">${m.currentAttack}</div>
        <div class="minion-health ${healthDamaged ? 'damaged' : ''}">${m.currentHealth}</div>
      </div>
    `;

    el.dataset.uid = m.uid;

    if (isMine && targetingSpell) {
      const spell = targetingSpell.card;
      if (spell.target === 'friendly_minion' || spell.target === 'friendly_any') {
        el.classList.add('targetable');
        el.onclick = () => {
          castSpell(targetingSpell.player, spell, targetingSpell.cardIndex, 'minion', m);
        };
      }
    } else if (!isMine && targetingSpell) {
      const spell = targetingSpell.card;
      if (spell.target === 'enemy_minion' || spell.target === 'enemy_any') {
        el.onclick = () => {
          castSpell(targetingSpell.player, spell, targetingSpell.cardIndex, 'minion', m);
        };
      }
    } else if (!isMine && battlecryTarget) {
      el.onclick = () => executeBattlecry(m);
    } else if (isMine && canAtk) {
      el.onclick = () => selectAttacker(m);
    } else if (!isMine && selectedAttacker) {
      el.onclick = () => attackTarget(m, playerKey);
    }

    el.onmouseenter = (e) => showTooltip(m, e);
    el.onmouseleave = () => hideTooltip();

    field.appendChild(el);
  });
}

function renderLog() {
  const logArea = document.getElementById('game-log');
  logArea.innerHTML = logs.slice(-15).map(l => `<div class="log-entry">${l}</div>`).join('');
  logArea.scrollTop = logArea.scrollHeight;
}

// ===== FLOATING TEXT =====
function showFloatingText(uid, text, type) {
  const el = document.querySelector(`[data-uid="${uid}"]`);
  if (!el) return;

  const rect = el.getBoundingClientRect();
  const ft = document.createElement('div');
  ft.className = `floating-text ${type}`;
  ft.textContent = text;
  ft.style.left = (rect.left + rect.width/2 - 10) + 'px';
  ft.style.top = (rect.top + rect.height/2 - 10) + 'px';
  document.body.appendChild(ft);

  el.classList.add(type === 'damage' ? 'damage-flash' : 'heal-flash');
  setTimeout(() => {
    el.classList.remove('damage-flash', 'heal-flash');
  }, 300);

  setTimeout(() => ft.remove(), 1000);
}

function showHeroFloatingText(player, text, type) {
  // AI Î™®ÎìúÏóêÏÑúÎäî Ìï≠ÏÉÅ P1 ÏãúÏ†ê, PVPÏóêÏÑúÎäî Ïã§Ï†ú DOM Í∏∞Ï§ÄÏúºÎ°ú ÌåêÎã®
  const isP1View = gameMode === 'ai' ? true : gameState.currentPlayer === 'p1';
  const heroId = (player === 'p1') === isP1View ? 'my-hero' : 'opponent-hero';
  const el = document.getElementById(heroId);
  if (!el) return;

  const rect = el.getBoundingClientRect();
  const ft = document.createElement('div');
  ft.className = `floating-text ${type}`;
  ft.textContent = text;
  ft.style.left = (rect.left + rect.width/2 - 10) + 'px';
  ft.style.top = (rect.top) + 'px';
  document.body.appendChild(ft);

  setTimeout(() => ft.remove(), 1000);
}

const aiBannerQueue = [];
let aiBannerPlaying = false;

function showAiActionBanner(text) {
  aiBannerQueue.push(text);
  if (!aiBannerPlaying) playNextAiBanner();
}

function playNextAiBanner() {
  if (aiBannerQueue.length === 0) { aiBannerPlaying = false; return; }
  aiBannerPlaying = true;
  const text = aiBannerQueue.shift();
  const banner = document.getElementById('ai-action-banner');
  if (!banner) { aiBannerPlaying = false; return; }
  banner.textContent = text;
  banner.style.display = 'block';
  banner.style.animation = 'none';
  void banner.offsetWidth;
  banner.style.animation = 'aiBannerFade 1.2s ease-out forwards';
  setTimeout(() => {
    banner.style.display = 'none';
    playNextAiBanner();
  }, 1300);
}

function triggerBattlecryFlash() {
  const flash = document.createElement('div');
  flash.className = 'screen-flash';
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 300);
}

// ===== TOOLTIP =====
function showTooltip(card, e) {
  const tooltip = document.getElementById('card-tooltip');
  tooltip.querySelector('.tooltip-name').textContent = card.name;
  tooltip.querySelector('.tooltip-desc').textContent = card.desc || 'ÏùºÎ∞ò ÎØ∏ÎãàÏñ∏';

  let stats = '';
  if (card.type === 'minion') {
    const atk = card.currentAttack !== undefined ? card.currentAttack : card.attack;
    const hp = card.currentHealth !== undefined ? card.currentHealth : card.health;
    stats = `Í≥µÍ≤©Î†•: ${atk} | Ï≤¥Î†•: ${hp} | ÎßàÎÇò: ${card.cost}`;
  } else {
    stats = `ÎßàÎÇò: ${card.cost} | Ï£ºÎ¨∏`;
  }
  tooltip.querySelector('.tooltip-stats').textContent = stats;

  tooltip.style.display = 'block';
  tooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 220) + 'px';
  tooltip.style.top = Math.min(e.clientY + 10, window.innerHeight - 100) + 'px';
}

function showHeroPowerTooltip(faction, e) {
  const cfg = FACTION_CONFIG[faction];
  const tooltip = document.getElementById('card-tooltip');
  tooltip.querySelector('.tooltip-name').textContent = cfg.powerName;
  tooltip.querySelector('.tooltip-desc').textContent = cfg.powerDesc;
  tooltip.querySelector('.tooltip-stats').textContent = '';
  tooltip.style.display = 'block';
  tooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 220) + 'px';
  tooltip.style.top = Math.min(e.clientY + 10, window.innerHeight - 100) + 'px';
}

function hideTooltip() {
  document.getElementById('card-tooltip').style.display = 'none';
}

// ===== LOGGING =====
function addLog(msg) {
  logs.push(msg);
  if (logs.length > 50) logs.shift();
}

// ===== MENU NAVIGATION =====
// ===== PAUSE MENU =====
function openPauseMenu() {
  document.getElementById('pause-menu').style.display = 'flex';
}

function closePauseMenu() {
  document.getElementById('pause-menu').style.display = 'none';
}

function openSettings() {
  document.getElementById('pause-menu').style.display = 'none';
  document.getElementById('settings-menu').style.display = 'flex';
  syncSettingsUI();
}

function closeSettings() {
  document.getElementById('settings-menu').style.display = 'none';
  document.getElementById('pause-menu').style.display = 'flex';
}

function showMainMenu() {
  document.getElementById('main-menu').style.display = 'flex';
  document.getElementById('faction-select').style.display = 'none';
  document.getElementById('game-board').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('turn-transition').style.display = 'none';
  document.getElementById('menu-dictionary').style.display = 'none';
  document.getElementById('pause-menu').style.display = 'none';
  document.getElementById('settings-menu').style.display = 'none';
  document.getElementById('menu-settings').style.display = 'none';
  document.getElementById('mulligan-screen').style.display = 'none';
  // ÏûîÏó¨ ÌîåÎ°úÌåÖ ÌÖçÏä§Ìä∏ / ÌôîÎ©¥ ÌîåÎûòÏãú DOM Ï†ïÎ¶¨
  document.querySelectorAll('.floating-text, .screen-flash').forEach(el => el.remove());
  gameState = null;
  pvpP1Faction = null;
  // ÏÑ∏Î†• ÏÑ†ÌÉù Ï†úÎ™©/Î≤ÑÌäº ÏõêÎ≥µ
  const factionTitle = document.querySelector('#faction-select h2');
  if (factionTitle) factionTitle.textContent = 'ÏÑ∏Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî';
  const factionBackBtn = document.querySelector('#faction-select .back-btn');
  if (factionBackBtn) factionBackBtn.textContent = 'Îí§Î°ú';
  playBGM('menu');
}

function startGame(mode) {
  gameMode = mode;
  pvpP1Faction = null;
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('faction-select').style.display = 'flex';
  const title = document.querySelector('#faction-select h2');
  title.textContent = mode === 'pvp' ? 'ÌîåÎ†àÏù¥Ïñ¥ 1 - ÏÑ∏Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî' : 'ÏÑ∏Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî';
}

function factionSelectBack() {
  if (gameMode === 'pvp' && pvpP1Faction !== null) {
    // P2 ÏÑ†ÌÉù ‚Üí P1 ÏÑ†ÌÉùÏúºÎ°ú Î≥µÍ∑Ä
    pvpP1Faction = null;
    const title = document.querySelector('#faction-select h2');
    title.textContent = 'ÌîåÎ†àÏù¥Ïñ¥ 1 - ÏÑ∏Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî';
    const backBtn = document.querySelector('#faction-select .back-btn');
    backBtn.textContent = 'Îí§Î°ú';
  } else {
    showMainMenu();
  }
}

function selectFaction(faction) {
  // PVP Î™®Îìú: P1 ÏÑ†ÌÉù Îã®Í≥Ñ
  if (gameMode === 'pvp' && pvpP1Faction === null) {
    playSound('click');
    pvpP1Faction = faction;
    const title = document.querySelector('#faction-select h2');
    title.textContent = 'ÌîåÎ†àÏù¥Ïñ¥ 2 - ÏÑ∏Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî';
    const backBtn = document.querySelector('#faction-select .back-btn');
    backBtn.textContent = 'Îí§Î°ú (P1 Îã§Ïãú ÏÑ†ÌÉù)';
    return;
  }

  // PVP Î™®Îìú: P2 ÏÑ†ÌÉù Îã®Í≥Ñ
  if (gameMode === 'pvp' && pvpP1Faction !== null) {
    selectedFaction = pvpP1Faction;
    window._vsOpponent = faction;
  } else {
    // AI Î™®Îìú: Í∏∞Ï°¥ ÎèôÏûë
    selectedFaction = faction;
  }

  document.getElementById('faction-select').style.display = 'none';
  showVSIntro(selectedFaction, () => {
    document.getElementById('game-board').style.display = 'flex';
    initGame();
  });
}

function showVSIntro(myFaction, callback) {
  let oppFaction;
  if (window._vsOpponent) {
    // PVP: P2Í∞Ä ÏßÅÏ†ë ÏÑ†ÌÉùÌïú ÏßÑÏòÅ ÏÇ¨Ïö©
    oppFaction = window._vsOpponent;
  } else {
    // AI: ÎûúÎç§ ÏÉÅÎåÄ
    const otherFactions = Object.keys(FACTION_CONFIG).filter(f => f !== myFaction);
    oppFaction = otherFactions[Math.floor(Math.random() * otherFactions.length)];
    window._vsOpponent = oppFaction;
  }

  const intro = document.getElementById('vs-intro');
  const left = document.getElementById('vs-left');
  const right = document.getElementById('vs-right');
  const vsText = document.getElementById('vs-text');

  document.getElementById('vs-emoji-left').textContent = getHeroEmoji(myFaction);
  document.getElementById('vs-name-left').textContent = getFactionName(myFaction);
  document.getElementById('vs-emoji-right').textContent = getHeroEmoji(oppFaction);
  document.getElementById('vs-name-right').textContent = getFactionName(oppFaction);

  // Ï¥àÍ∏∞Ìôî
  left.className = 'vs-fighter left';
  right.className = 'vs-fighter right';
  vsText.className = 'vs-text';

  intro.style.display = 'flex';
  stopBGM();
  playSound('gamestart');

  // ÏàúÏ∞® Ïï†ÎãàÎ©îÏù¥ÏÖò
  setTimeout(() => left.classList.add('animate-in-left'), 100);
  setTimeout(() => right.classList.add('animate-in-right'), 300);
  setTimeout(() => vsText.classList.add('animate-vs'), 200);

  // Ïù∏Ìä∏Î°ú Ï¢ÖÎ£å
  setTimeout(() => {
    intro.style.display = 'none';
    callback();
  }, 2200);
}

function rematch() {
  // PVP: ÏñëÏ∏° ÏßÑÏòÅ Ïú†ÏßÄ
  if (gameMode === 'pvp' && gameState) {
    window._vsOpponent = gameState.p2.faction;
  }
  document.getElementById('game-over').style.display = 'none';
  showVSIntro(selectedFaction, () => {
    initGame();
  });
}

// Mouse move for attack arrow
document.addEventListener('mousemove', (e) => {
  if (attackArrowStart && selectedAttacker) {
    showAttackArrow(attackArrowStart.x, attackArrowStart.y, e.clientX, e.clientY);
  }
});

// Touch move for attack arrow (mobile)
document.addEventListener('touchmove', (e) => {
  if (attackArrowStart && selectedAttacker && e.touches.length > 0) {
    showAttackArrow(attackArrowStart.x, attackArrowStart.y, e.touches[0].clientX, e.touches[0].clientY);
  }
});

// Right click to cancel
document.addEventListener('contextmenu', (e) => {
  if (selectedAttacker || targetingSpell || battlecryTarget) {
    e.preventDefault();
    cancelTargeting();
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    // Î©îÎâ¥ ÎèÑÍ∞ê: Ïπ¥Îìú Î™©Î°ù ‚Üí ÏßÑÏòÅ ÏÑ†ÌÉù
    const menuDict = document.getElementById('menu-dictionary');
    if (menuDict.style.display === 'flex') {
      playSound('book'); backToMenuDictSelect(); return;
    }
    // Î©îÎâ¥ ÎèÑÍ∞ê: ÏßÑÏòÅ ÏÑ†ÌÉù ‚Üí Î©îÏù∏ Î©îÎâ¥
    const menuDictSelect = document.getElementById('menu-dict-select');
    if (menuDictSelect.style.display === 'flex') {
      playSound('book'); closeMenuDictSelect(); return;
    }

    // ÏÑ∏Î†• ÏÑ†ÌÉù ÌôîÎ©¥ ESC
    const factionSelect = document.getElementById('faction-select');
    if (factionSelect.style.display === 'flex') {
      playSound('click'); factionSelectBack(); return;
    }

    // Î©îÏù∏ Î©îÎâ¥ ÏÑ§Ï†ï ESC
    const menuSettings = document.getElementById('menu-settings');
    if (menuSettings.style.display === 'flex') {
      playSound('click'); closeMenuSettings(); return;
    }

    // Í≤åÏûÑ ÎÇ¥ ESC
    const gameBoard = document.getElementById('game-board');
    if (gameBoard.style.display !== 'flex') return;
    const settings = document.getElementById('settings-menu');
    if (settings.style.display === 'flex') {
      closeSettings();
    } else {
      const pause = document.getElementById('pause-menu');
      if (pause.style.display === 'flex') {
        closePauseMenu();
      } else {
        openPauseMenu();
      }
    }
  }
});

// ===== DECK VIEWER =====
function toggleDeckViewer() {
  playSound('book');
  const viewer = document.getElementById('deck-viewer');
  if (viewer.style.display === 'flex') {
    viewer.style.display = 'none';
  } else {
    openDeckViewer();
  }
}

function openDeckViewer() {
  if (!gameState) return;
  const myKey = (gameMode === 'ai' || gameState.currentPlayer === 'p1') ? 'p1' : 'p2';
  const my = gameState[myKey];
  const remaining = [...my.deck].sort((a, b) => a.cost - b.cost || a.name.localeCompare(b.name));

  document.getElementById('deck-viewer-subtitle').textContent = `${remaining.length}Ïû• ÎÇ®Ïùå`;

  const fclass = getFactionClass(my.faction);
  let html = '<div class="dict-grid">';
  remaining.forEach(c => {
    if (c.type === 'minion') {
      const kwText = (c.keywords || []).map(k => {
        switch(k) { case 'taunt': return 'ÎèÑÎ∞ú'; case 'rush': return 'ÎèåÏßÑ'; case 'poison': return 'ÎèÖ'; case 'lifesteal': return 'Ìù°Ïàò'; default: return k; }
      }).join(', ');
      const desc = c.desc || kwText || '';
      html += `
        <div class="dict-card ${fclass}">
          <div class="dc-left">
            <div class="dc-emoji">${c.emoji}</div>
            <div class="dc-mana">${c.cost}</div>
          </div>
          <div class="dc-right">
            <div class="dc-name">${c.name}</div>
            <div class="dc-desc">${desc}</div>
            <div class="dc-stats"><div class="dc-atk">${c.attack}</div><div class="dc-hp">${c.health}</div></div>
          </div>
        </div>`;
    } else {
      html += `
        <div class="dict-card ${fclass}">
          <div class="dc-left">
            <div class="dc-emoji">${c.emoji}</div>
            <div class="dc-mana">${c.cost}</div>
          </div>
          <div class="dc-right">
            <div class="dc-name">${c.name}</div>
            <div class="dc-desc">${c.desc}</div>
          </div>
        </div>`;
    }
  });
  html += '</div>';

  document.getElementById('deck-viewer-content').innerHTML = html;
  document.getElementById('deck-viewer').style.display = 'flex';
}

// ===== CARD DICTIONARY =====
function toggleDictionary() {
  playSound('book');
  const dict = document.getElementById('card-dictionary');
  const toggle = document.getElementById('dict-toggle');
  if (dict.style.display === 'flex') {
    dict.style.display = 'none';
    toggle.classList.remove('open');
  } else {
    openDictionary();
    toggle.classList.add('open');
  }
}

function openDictionary() {
  if (!gameState) return;

  const myKey = (gameMode === 'ai' || gameState.currentPlayer === 'p1') ? 'p1' : 'p2';
  const myFaction = gameState[myKey].faction;
  const oppFaction = gameState[myKey === 'p1' ? 'p2' : 'p1'].faction;
  const myCards = FACTION_CONFIG[myFaction].cards;
  const oppCards = FACTION_CONFIG[oppFaction].cards;

  const title = document.getElementById('dict-title');
  const subtitle = document.getElementById('dict-subtitle');
  title.textContent = 'Ïπ¥Îìú ÎèÑÍ∞ê';
  subtitle.textContent = `Ï†ÑÏ≤¥ ${myCards.length + oppCards.length}Ï¢Ö`;

  let html = '';
  html += renderDictFaction(getFactionName(myFaction), myCards, getFactionClass(myFaction));
  html += renderDictFaction(getFactionName(oppFaction), oppCards, getFactionClass(oppFaction));

  document.getElementById('dict-content').innerHTML = html;
  document.getElementById('card-dictionary').style.display = 'flex';
}

function renderDictFaction(factionName, cards, fclass) {
  const minions = cards.filter(c => c.type === 'minion');
  const spells = cards.filter(c => c.type === 'spell');
  let html = '';

  html += `<div class="dict-section"><h3>${factionName} ÎØ∏ÎãàÏñ∏ (${minions.length}Ï¢Ö)</h3><div class="dict-grid">`;
  minions.forEach(c => {
    const kwText = (c.keywords || []).map(k => {
      switch(k) { case 'taunt': return 'ÎèÑÎ∞ú'; case 'rush': return 'ÎèåÏßÑ'; case 'poison': return 'ÎèÖ'; case 'lifesteal': return 'Ìù°Ïàò'; default: return k; }
    }).join(', ');
    const desc = c.desc || kwText || '';
    html += `
      <div class="dict-card ${fclass}">
        <div class="dc-left">
          <div class="dc-emoji">${c.emoji}</div>
          <div class="dc-mana">${c.cost}</div>
        </div>
        <div class="dc-right">
          <div class="dc-name">${c.name}</div>
          <div class="dc-desc">${desc}</div>
          <div class="dc-stats"><div class="dc-atk">${c.attack}</div><div class="dc-hp">${c.health}</div></div>
        </div>
      </div>`;
  });
  html += '</div></div>';

  html += `<div class="dict-section"><h3>${factionName} Ï£ºÎ¨∏ (${spells.length}Ï¢Ö)</h3><div class="dict-grid">`;
  spells.forEach(c => {
    html += `
      <div class="dict-card ${fclass}">
        <div class="dc-left">
          <div class="dc-emoji">${c.emoji}</div>
          <div class="dc-mana">${c.cost}</div>
        </div>
        <div class="dc-right">
          <div class="dc-name">${c.name}</div>
          <div class="dc-desc">${c.desc}</div>
        </div>
      </div>`;
  });
  html += '</div></div>';

  return html;
}

// ===== MENU DICTIONARY =====
function openMenuDictionary() {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('menu-dict-select').style.display = 'flex';

  // ÏßÑÏòÅ ÏÑ†ÌÉù Ïπ¥Îìú ÏÉùÏÑ±
  const container = document.getElementById('menu-dict-factions');
  container.innerHTML = '';
  Object.keys(FACTION_CONFIG).forEach(f => {
    const cfg = FACTION_CONFIG[f];
    const card = document.createElement('div');
    card.className = `faction-card ${f}`;
    card.innerHTML = `
      <div class="faction-icon">${cfg.emoji}</div>
      <h3>${cfg.name}</h3>
      <p>${cfg.cards.length}Ï¢Ö</p>
    `;
    card.onclick = () => { playSound('book'); openMenuDictFaction(f); };
    container.appendChild(card);
  });
}

function openMenuDictFaction(faction) {
  document.getElementById('menu-dict-select').style.display = 'none';
  document.getElementById('menu-dictionary').style.display = 'flex';

  const cfg = FACTION_CONFIG[faction];
  document.getElementById('menu-dict-title').textContent = `üìñ ${cfg.name} Ïπ¥Îìú ÎèÑÍ∞ê`;

  const html = renderDictFaction(cfg.name, cfg.cards, cfg.cardClass);
  document.getElementById('menu-dict-content').innerHTML = html;
}

function backToMenuDictSelect() {
  document.getElementById('menu-dictionary').style.display = 'none';
  document.getElementById('menu-dict-select').style.display = 'flex';
}

function closeMenuDictSelect() {
  document.getElementById('menu-dict-select').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
}

function openMenuSettings() {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('menu-settings').style.display = 'flex';
  syncSettingsUI();
}

function closeMenuSettings() {
  document.getElementById('menu-settings').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
}

function syncSettingsUI() {
  const val = Math.round(sfxVolume * 100);
  const bgmVal = Math.round(bgmVolume * 100);
  // Î©îÏù∏ Î©îÎâ¥ ÏÑ§Ï†ï
  const menuSfx = document.getElementById('menu-sfx-toggle');
  const menuVol = document.getElementById('menu-volume-slider');
  const menuLabel = document.getElementById('menu-volume-label');
  if (menuSfx) menuSfx.checked = sfxEnabled;
  if (menuVol) menuVol.value = val;
  if (menuLabel) menuLabel.textContent = val + '%';
  // Í≤åÏûÑ ÎÇ¥ ÏÑ§Ï†ï
  const gameSfx = document.getElementById('sfx-toggle');
  const gameVol = document.getElementById('volume-slider');
  const gameLabel = document.getElementById('volume-label');
  if (gameSfx) gameSfx.checked = sfxEnabled;
  if (gameVol) gameVol.value = val;
  if (gameLabel) gameLabel.textContent = val + '%';
  // BGM
  document.querySelectorAll('#bgm-toggle, #menu-bgm-toggle').forEach(el => el.checked = bgmEnabled);
  document.querySelectorAll('#bgm-slider, #menu-bgm-slider').forEach(el => el.value = bgmVal);
  document.querySelectorAll('#bgm-label, #menu-bgm-label').forEach(el => el.textContent = bgmVal + '%');
}

function setVolume(val) {
  sfxVolume = val / 100;
  document.querySelectorAll('#volume-label, #menu-volume-label').forEach(el => el.textContent = val + '%');
  document.querySelectorAll('#volume-slider, #menu-volume-slider').forEach(el => el.value = val);
}

function toggleSfx(enabled) {
  sfxEnabled = enabled;
  document.querySelectorAll('#sfx-toggle, #menu-sfx-toggle').forEach(el => el.checked = enabled);
}

function toggleBGM(enabled) {
  bgmEnabled = enabled;
  document.querySelectorAll('#bgm-toggle, #menu-bgm-toggle').forEach(el => el.checked = enabled);
  if (enabled) {
    playBGM(gameState ? 'battle' : 'menu');
  } else {
    stopBGM();
  }
}

function setBGMVolume(val) {
  bgmVolume = val / 100;
  updateBGMVolume(bgmVolume);
  document.querySelectorAll('#bgm-label, #menu-bgm-label').forEach(el => el.textContent = val + '%');
  document.querySelectorAll('#bgm-slider, #menu-bgm-slider').forEach(el => el.value = val);
}

// Ï≤´ ÌÅ¥Î¶≠ Ïãú BGM ÏãúÏûë (Î∏åÎùºÏö∞Ï†Ä Ïò§ÎîîÏò§ Ï†ïÏ±Ö)
document.addEventListener('click', function startBGMOnce() {
  if (bgmEnabled && !bgmNodes) playBGM('menu');
  document.removeEventListener('click', startBGMOnce);
}, { once: true });
</script>
</body>
</html>
