<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ì¸ê°„ vs ì•…ë§ˆ - ì¹´ë“œ ë°°í‹€</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Segoe UI', sans-serif;
  background: #1a1a2e;
  color: #fff;
  overflow: hidden;
  height: 100vh;
  user-select: none;
}

/* ===== MAIN MENU ===== */
#main-menu {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
}

#main-menu h1 {
  font-size: 3em;
  margin-bottom: 10px;
  text-shadow: 0 0 20px rgba(255,100,50,0.5);
}

#main-menu .subtitle {
  font-size: 1.2em;
  color: #aaa;
  margin-bottom: 40px;
}

.menu-btn {
  padding: 15px 0;
  width: 220px;
  margin: 10px;
  font-size: 1.2em;
  text-align: center;
  border: 2px solid #555;
  background: rgba(255,255,255,0.05);
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s;
}

.menu-btn:hover {
  background: rgba(255,255,255,0.15);
  border-color: #f0a;
  transform: scale(1.05);
}

/* ===== FACTION SELECT ===== */
#faction-select {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
}

#faction-select h2 {
  font-size: 2em;
  margin-bottom: 30px;
}

.faction-cards {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 960px;
}

.faction-card {
  width: 170px;
  padding: 20px;
  border: 3px solid #555;
  border-radius: 15px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s;
}

.faction-card:hover {
  transform: translateY(-10px);
}

.faction-card.human {
  background: linear-gradient(180deg, #2a1f0e, #1a1508);
  border-color: #c9a84c;
}

.faction-card.human:hover {
  box-shadow: 0 0 30px rgba(201,168,76,0.4);
}

.faction-card.demon {
  background: linear-gradient(180deg, #2e0a0a, #1a0505);
  border-color: #c0392b;
}

.faction-card.demon:hover {
  box-shadow: 0 0 30px rgba(192,57,43,0.4);
}

.faction-card.elf {
  background: linear-gradient(180deg, #0a2e1a, #051a0f);
  border-color: #2ecc71;
}
.faction-card.elf:hover {
  box-shadow: 0 0 30px rgba(46,204,113,0.4);
}

.faction-card.druid {
  background: linear-gradient(180deg, #2e1f0a, #1a1205);
  border-color: #e67e22;
}
.faction-card.druid:hover {
  box-shadow: 0 0 30px rgba(230,126,34,0.4);
}

.faction-card.dwarf {
  background: linear-gradient(180deg, #1a1a2e, #0f0f1a);
  border-color: #95a5a6;
}
.faction-card.dwarf:hover {
  box-shadow: 0 0 30px rgba(149,165,166,0.4);
}

.faction-icon {
  font-size: 3em;
  margin-bottom: 15px;
}

.faction-card h3 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.faction-card p {
  color: #aaa;
  font-size: 0.9em;
  line-height: 1.5;
}

.back-btn {
  margin-top: 30px;
  padding: 10px 30px;
  background: rgba(255,255,255,0.1);
  border: 1px solid #555;
  color: #aaa;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1em;
}

.back-btn:hover {
  background: rgba(255,255,255,0.2);
  color: #fff;
}

/* ===== GAME BOARD ===== */
#game-board {
  display: none;
  flex-direction: column;
  height: 100vh;
  background: linear-gradient(180deg, #0d1117, #161b22, #0d1117);
  position: relative;
}

/* Top bar */
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 15px;
  background: rgba(0,0,0,0.3);
  font-size: 0.85em;
  height: 35px;
}

.top-bar .game-info { color: #888; }
.top-bar .menu-link { color: #666; cursor: pointer; }
.top-bar .menu-link:hover { color: #fff; }

/* Player areas */
.player-area {
  display: flex;
  align-items: center;
  padding: 5px 15px;
  height: 60px;
  gap: 10px;
}

.player-area.opponent { background: rgba(100,0,0,0.1); }
.player-area.mine { background: rgba(0,0,100,0.1); }

.hero-portrait {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: 2px solid #555;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  flex-shrink: 0;
  position: relative;
  cursor: pointer;
}

.hero-portrait.human-hero { border-color: #c9a84c; background: #2a1f0e; }
.hero-portrait.demon-hero { border-color: #c0392b; background: #2e0a0a; }
.hero-portrait.elf-hero { border-color: #2ecc71; background: #0a2e1a; }
.hero-portrait.druid-hero { border-color: #e67e22; background: #2e1f0a; }
.hero-portrait.dwarf-hero { border-color: #95a5a6; background: #1a1a2e; }

.hero-portrait.targetable {
  animation: targetPulse 1s infinite;
  cursor: crosshair;
}

@keyframes targetPulse {
  0%, 100% { box-shadow: 0 0 5px rgba(255,0,0,0.5); }
  50% { box-shadow: 0 0 15px rgba(255,0,0,0.8); }
}

.hero-hp {
  position: absolute;
  bottom: -4px;
  right: -4px;
  background: #c0392b;
  color: #fff;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  font-size: 0.55em;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  border: 2px solid #1a1a2e;
}

.hero-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.hero-name {
  font-size: 0.9em;
  font-weight: bold;
}

.mana-bar {
  display: flex;
  align-items: center;
  gap: 3px;
  font-size: 0.75em;
}

.mana-crystal {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid #2980b9;
  background: transparent;
}

.mana-crystal.filled {
  background: #3498db;
  box-shadow: 0 0 4px rgba(52,152,219,0.5);
}

.mana-text {
  color: #3498db;
  font-weight: bold;
  margin-left: 5px;
}

.hero-power-btn {
  padding: 4px 12px;
  border-radius: 8px;
  border: 2px solid #555;
  background: rgba(255,255,255,0.05);
  color: #ccc;
  font-size: 0.75em;
  cursor: pointer;
  margin-left: auto;
  transition: all 0.2s;
  white-space: nowrap;
  position: relative;
}

.hero-power-btn:hover:not(.used):not(.disabled) {
  background: rgba(255,255,255,0.15);
  border-color: #3498db;
}


.hero-power-btn.used {
  opacity: 0.4;
  cursor: not-allowed;
}

.hero-power-btn.disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.deck-count {
  margin-left: auto;
  padding: 4px 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 5px;
  font-size: 0.8em;
  color: #888;
  cursor: pointer;
  transition: all 0.2s;
}

.deck-count:hover {
  background: rgba(255,255,255,0.12);
  color: #ccc;
}

#deck-viewer {
  display: none;
  position: absolute;
  right: 10px;
  bottom: 180px;
  width: 320px;
  max-height: 55vh;
  background: rgba(15,12,30,0.97);
  border: 2px solid #3498db;
  border-radius: 12px;
  z-index: 20;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 -5px 30px rgba(52,152,219,0.3);
  animation: dictSlideUp 0.25s ease-out;
}

/* Hand area */
.hand-area {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 5px;
  min-height: 120px;
  gap: 3px;
  overflow-x: auto;
}

.hand-area.opponent-hand {
  min-height: 60px;
}

/* Field area */
.field-area {
  display: flex;
  justify-content: center;
  align-items: center;
  flex: 1;
  gap: 5px;
  padding: 5px;
  min-height: 100px;
  border-top: 1px solid rgba(255,255,255,0.05);
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

.field-area.opponent-field {
  background: rgba(200,0,0,0.03);
}

.field-area.my-field {
  background: rgba(0,0,200,0.03);
}

/* Card styles */
.card {
  width: 80px;
  min-width: 80px;
  height: 110px;
  border-radius: 8px;
  border: 2px solid #555;
  display: flex;
  flex-direction: column;
  position: relative;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  overflow: hidden;
  font-size: 0.7em;
}

.card.in-hand:hover {
  transform: translateY(-15px) scale(1.1);
  z-index: 100;
  box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}

.card.playable {
  border-color: #2ecc71;
  box-shadow: 0 0 8px rgba(46,204,113,0.3);
}

.card.human-card {
  background: linear-gradient(180deg, #3d2e10, #2a1f0e);
  border-color: #8b7340;
}

.card.demon-card {
  background: linear-gradient(180deg, #3d1010, #2e0a0a);
  border-color: #8b3030;
}

.card.elf-card {
  background: linear-gradient(180deg, #103d1a, #0a2e10);
  border-color: #308b50;
}

.card.druid-card {
  background: linear-gradient(180deg, #3d2a10, #2e1f0a);
  border-color: #8b6530;
}

.card.dwarf-card {
  background: linear-gradient(180deg, #252535, #1a1a2e);
  border-color: #6b7b8b;
}

.card.spell-card {
  border-style: dashed;
}

.card-back {
  width: 55px;
  min-width: 55px;
  height: 75px;
  border-radius: 6px;
  background: linear-gradient(135deg, #2c3e50, #34495e);
  border: 2px solid #4a6785;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
}

.card-mana {
  position: absolute;
  top: -1px;
  left: -1px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #2980b9;
  color: #fff;
  font-size: 0.9em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  border: 1px solid #1a5276;
}

.card-art {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  padding-top: 8px;
}

.card-name {
  text-align: center;
  font-size: 0.8em;
  font-weight: bold;
  padding: 1px 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.card-desc {
  text-align: center;
  font-size: 0.65em;
  color: #aaa;
  padding: 1px 3px;
  min-height: 20px;
  line-height: 1.2;
}

.card-stats {
  display: flex;
  justify-content: space-between;
  padding: 0 2px 2px;
}

.card-attack, .card-health {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  font-size: 0.85em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
}

.card-attack {
  background: #e67e22;
  color: #fff;
  border: 1px solid #d35400;
}

.card-health {
  background: #c0392b;
  color: #fff;
  border: 1px solid #96281b;
}

/* Field minion */
.field-minion {
  width: 75px;
  min-width: 75px;
  height: 95px;
  border-radius: 8px;
  border: 2px solid #555;
  display: flex;
  flex-direction: column;
  position: relative;
  cursor: pointer;
  transition: all 0.2s;
  overflow: hidden;
  font-size: 0.7em;
}

.field-minion.human-card {
  background: linear-gradient(180deg, #3d2e10, #2a1f0e);
}

.field-minion.demon-card {
  background: linear-gradient(180deg, #3d1010, #2e0a0a);
}

.field-minion.elf-card {
  background: linear-gradient(180deg, #103d1a, #0a2e10);
}

.field-minion.druid-card {
  background: linear-gradient(180deg, #3d2a10, #2e1f0a);
}

.field-minion.dwarf-card {
  background: linear-gradient(180deg, #252535, #1a1a2e);
}

.field-minion.can-attack {
  border-color: #2ecc71;
  box-shadow: 0 0 8px rgba(46,204,113,0.4);
  cursor: pointer;
}

.field-minion.taunt {
  border-color: #f1c40f;
  border-width: 3px;
  box-shadow: 0 0 8px rgba(241,196,15,0.3);
}

.field-minion.targetable {
  animation: targetPulse 1s infinite;
  cursor: crosshair;
}

.field-minion.selected {
  border-color: #e74c3c;
  box-shadow: 0 0 15px rgba(231,76,60,0.6);
  transform: scale(1.05);
}

.field-minion .minion-art {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.8em;
}

.field-minion .minion-name {
  text-align: center;
  font-size: 0.7em;
  padding: 1px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.field-minion .minion-keywords {
  text-align: center;
  font-size: 0.6em;
  color: #f1c40f;
  height: 12px;
}

.field-minion .minion-stats {
  display: flex;
  justify-content: space-between;
  padding: 0 2px 2px;
}

.field-minion .minion-attack, .field-minion .minion-health {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  font-size: 0.85em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
}

.field-minion .minion-attack {
  background: #e67e22;
  color: #fff;
}

.field-minion .minion-health {
  background: #c0392b;
  color: #fff;
}

.field-minion .minion-health.damaged {
  background: #e74c3c;
}

/* End turn button */
.end-turn-btn {
  position: absolute;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  padding: 12px 20px;
  background: linear-gradient(180deg, #e67e22, #d35400);
  border: 2px solid #e67e22;
  color: #fff;
  font-size: 1em;
  font-weight: bold;
  border-radius: 25px;
  cursor: pointer;
  z-index: 10;
  transition: all 0.2s;
}

.end-turn-btn:hover {
  transform: translateY(-50%) scale(1.05);
  box-shadow: 0 0 15px rgba(230,126,34,0.5);
}

.end-turn-btn.disabled {
  background: #555;
  border-color: #555;
  cursor: not-allowed;
}

/* Center divider */
.board-divider {
  height: 3px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
  position: relative;
}

/* Turn transition overlay */
#turn-transition {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.95);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#turn-transition h2 {
  font-size: 2.5em;
  margin-bottom: 20px;
}

#turn-transition p {
  color: #aaa;
  margin-bottom: 30px;
}

#turn-transition button {
  padding: 15px 40px;
  font-size: 1.2em;
  background: #e67e22;
  border: none;
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
}

/* Game over overlay */
#game-over {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.9);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#game-over h2 {
  font-size: 3em;
  margin-bottom: 10px;
}

#game-over .result-text {
  font-size: 1.5em;
  margin-bottom: 30px;
  color: #aaa;
}

#game-over button {
  padding: 15px 0;
  width: 220px;
  font-size: 1.2em;
  background: #e67e22;
  border: none;
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
  margin: 5px;
  text-align: center;
}

/* Log area */
.log-area {
  position: absolute;
  left: 5px;
  top: 50%;
  transform: translateY(-50%);
  width: 180px;
  max-height: 200px;
  overflow-y: auto;
  background: rgba(0,0,0,0.5);
  border-radius: 8px;
  padding: 8px;
  font-size: 0.7em;
  color: #888;
  z-index: 5;
}

.log-area .log-entry {
  padding: 2px 0;
  border-bottom: 1px solid rgba(255,255,255,0.05);
}

/* Damage animation */
.damage-flash {
  animation: damageFlash 0.3s ease-out;
}

@keyframes damageFlash {
  0% { filter: brightness(1); }
  50% { filter: brightness(3) hue-rotate(350deg); }
  100% { filter: brightness(1); }
}

.heal-flash {
  animation: healFlash 0.3s ease-out;
}

@keyframes healFlash {
  0% { filter: brightness(1); }
  50% { filter: brightness(2) hue-rotate(90deg); }
  100% { filter: brightness(1); }
}

/* Floating damage text */
.floating-text {
  position: absolute;
  font-size: 1.5em;
  font-weight: bold;
  pointer-events: none;
  z-index: 999;
  animation: floatUp 1s ease-out forwards;
}

.floating-text.damage { color: #e74c3c; }
.floating-text.heal { color: #2ecc71; }

@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-40px) scale(1.5); }
}

/* Card tooltip */
.card-tooltip {
  display: none;
  position: fixed;
  background: rgba(20,20,40,0.97);
  border: 2px solid #666;
  border-radius: 10px;
  padding: 12px;
  z-index: 500;
  width: 200px;
  pointer-events: none;
}

.card-tooltip .tooltip-name {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 5px;
}

.card-tooltip .tooltip-desc {
  color: #ccc;
  font-size: 0.9em;
  line-height: 1.4;
}

.card-tooltip .tooltip-stats {
  margin-top: 8px;
  color: #aaa;
  font-size: 0.85em;
}

/* Attack arrow */
.attack-arrow {
  position: fixed;
  pointer-events: none;
  z-index: 800;
}

.attack-line {
  stroke: #e74c3c;
  stroke-width: 3;
  stroke-dasharray: 8, 4;
  animation: dashMove 0.5s linear infinite;
}

@keyframes dashMove {
  to { stroke-dashoffset: -12; }
}

/* Coin card special */
.card.coin-card {
  border-color: #f1c40f;
  background: linear-gradient(180deg, #4a3f10, #2a2508);
}

/* Responsive */
@media (max-width: 768px) {
  .card { width: 65px; min-width: 65px; height: 95px; font-size: 0.6em; }
  .field-minion { width: 60px; min-width: 60px; height: 80px; font-size: 0.6em; }
  .card-back { width: 40px; min-width: 40px; height: 60px; }
  .log-area { display: none; }
}

/* Spell target selection */
.spell-target-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.3);
  z-index: 50;
}

.cancel-target {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 30px;
  background: #c0392b;
  border: none;
  color: #fff;
  border-radius: 8px;
  cursor: pointer;
  z-index: 60;
  font-size: 1em;
  display: none;
}

/* Card dictionary */
.dict-toggle {
  position: absolute;
  left: 15px;
  bottom: 130px;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 2px solid #8e44ad;
  background: rgba(142,68,173,0.2);
  color: #c39bd3;
  font-size: 1.3em;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 15;
}

.dict-toggle:hover {
  background: rgba(142,68,173,0.45);
  color: #fff;
  transform: scale(1.1);
  box-shadow: 0 0 12px rgba(142,68,173,0.5);
}

.dict-toggle.open {
  background: #8e44ad;
  color: #fff;
  border-color: #a569bd;
}

#card-dictionary {
  display: none;
  position: absolute;
  left: 10px;
  bottom: 180px;
  width: 320px;
  max-height: 55vh;
  background: rgba(15,12,30,0.97);
  border: 2px solid #8e44ad;
  border-radius: 12px;
  z-index: 20;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 -5px 30px rgba(142,68,173,0.3);
  animation: dictSlideUp 0.25s ease-out;
}

@keyframes dictSlideUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.dict-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  background: rgba(142,68,173,0.15);
  border-bottom: 1px solid rgba(142,68,173,0.3);
  flex-shrink: 0;
}

.dict-header h2 {
  font-size: 1em;
  margin: 0;
}

.dict-header .dict-subtitle {
  color: #888;
  font-size: 0.75em;
  margin: 0;
}

.dict-close-x {
  width: 26px;
  height: 26px;
  border-radius: 50%;
  border: none;
  background: rgba(255,255,255,0.1);
  color: #aaa;
  font-size: 1em;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.dict-close-x:hover {
  background: rgba(255,255,255,0.25);
  color: #fff;
}

.dict-body {
  overflow-y: auto;
  padding: 10px;
  flex: 1;
}

.dict-section {
  margin-bottom: 15px;
}

.dict-section h3 {
  font-size: 0.85em;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
  color: #c39bd3;
}

.dict-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px;
}

.dict-card {
  border-radius: 8px;
  border: 1px solid #444;
  padding: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.75em;
  transition: background 0.2s;
  cursor: default;
}

.dict-card:hover {
  background: rgba(255,255,255,0.05);
}

.dict-card.human-card {
  background: rgba(60,45,16,0.5);
  border-color: rgba(139,115,64,0.4);
}

.dict-card.demon-card {
  background: rgba(60,16,16,0.5);
  border-color: rgba(139,48,48,0.4);
}

.dict-card.elf-card {
  background: rgba(16,60,26,0.5);
  border-color: rgba(48,139,80,0.4);
}

.dict-card.druid-card {
  background: rgba(60,42,16,0.5);
  border-color: rgba(139,101,48,0.4);
}

.dict-card.dwarf-card {
  background: rgba(37,37,53,0.5);
  border-color: rgba(107,123,139,0.4);
}

.dict-card .dc-left {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex-shrink: 0;
  width: 36px;
}

.dict-card .dc-emoji {
  font-size: 1.5em;
  line-height: 1;
}

.dict-card .dc-mana {
  background: #2980b9;
  color: #fff;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.8em;
  margin-top: 2px;
}

.dict-card .dc-right {
  flex: 1;
  min-width: 0;
}

.dict-card .dc-name {
  font-weight: bold;
  font-size: 0.9em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dict-card .dc-desc {
  color: #999;
  font-size: 0.75em;
  line-height: 1.2;
  margin-top: 1px;
}

.dict-card .dc-stats {
  display: flex;
  gap: 4px;
  margin-top: 3px;
}

.dict-card .dc-atk, .dict-card .dc-hp {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.8em;
}

.dict-card .dc-atk {
  background: #e67e22;
  color: #fff;
}

.dict-card .dc-hp {
  background: #c0392b;
  color: #fff;
}

/* ===== PAUSE MENU ===== */
#pause-menu, #settings-menu {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
}

#pause-menu h2, #settings-menu h2 {
  font-size: 2em;
  margin-bottom: 20px;
}

.pause-btn {
  padding: 12px 0;
  width: 200px;
  font-size: 1.1em;
  border: 2px solid #555;
  background: rgba(255,255,255,0.08);
  color: #fff;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.pause-btn:hover {
  background: rgba(255,255,255,0.18);
  border-color: #aaa;
  transform: scale(1.03);
}

.pause-btn-danger {
  border-color: #c0392b;
  color: #e74c3c;
}

.pause-btn-danger:hover {
  background: rgba(192,57,43,0.2);
  border-color: #e74c3c;
}

.settings-row {
  display: flex;
  align-items: center;
  gap: 15px;
  width: 260px;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 1em;
}

.settings-row input[type="range"] {
  flex: 1;
  accent-color: #e67e22;
}

/* Toggle switch */
.toggle-switch {
  position: relative;
  width: 48px;
  height: 26px;
}

.toggle-switch input { opacity: 0; width: 0; height: 0; }

.toggle-slider {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: #555;
  border-radius: 26px;
  cursor: pointer;
  transition: 0.3s;
}

.toggle-slider::before {
  content: '';
  position: absolute;
  width: 20px; height: 20px;
  left: 3px; bottom: 3px;
  background: #fff;
  border-radius: 50%;
  transition: 0.3s;
}

.toggle-switch input:checked + .toggle-slider {
  background: #e67e22;
}

.toggle-switch input:checked + .toggle-slider::before {
  transform: translateX(22px);
}
</style>
</head>
<body>

<!-- MAIN MENU -->
<div id="main-menu">
  <h1>ì¸ê°„ vs ì•…ë§ˆ</h1>
  <p class="subtitle">ì¹´ë“œ ë°°í‹€</p>
  <button class="menu-btn" onclick="playSound('click'); startGame('ai')">AI ëŒ€ì „</button>
  <button class="menu-btn" onclick="playSound('click'); startGame('pvp')">2ì¸ ëŒ€ì „</button>
  <button class="menu-btn" onclick="playSound('book'); openMenuDictionary()">ğŸ“– ì¹´ë“œ ë„ê°</button>
  <button class="menu-btn" onclick="playSound('click'); openMenuSettings()">âš™ï¸ ì„¤ì •</button>
</div>

<!-- MENU SETTINGS -->
<div id="menu-settings" style="display:none; flex-direction:column; align-items:center; justify-content:center; height:100vh; background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);">
  <h2 style="margin-bottom:30px;">âš™ï¸ ì„¤ì •</h2>
  <div class="settings-row">
    <span>íš¨ê³¼ìŒ</span>
    <label class="toggle-switch">
      <input type="checkbox" id="menu-sfx-toggle" checked onchange="toggleSfx(this.checked)">
      <span class="toggle-slider"></span>
    </label>
  </div>
  <div class="settings-row">
    <span>ìŒëŸ‰</span>
    <input type="range" id="menu-volume-slider" min="0" max="100" value="50" oninput="setVolume(this.value)">
    <span id="menu-volume-label">50%</span>
  </div>
  <button class="back-btn" onclick="playSound('click'); closeMenuSettings()" style="margin-top:30px;">ë’¤ë¡œ</button>
</div>

<!-- MENU DICTIONARY: Faction Select -->
<div id="menu-dict-select" style="display:none; flex-direction:column; align-items:center; justify-content:center; height:100vh; background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);">
  <h2 style="margin-bottom:30px;">ğŸ“– ì¹´ë“œ ë„ê°</h2>
  <div class="faction-cards" id="menu-dict-factions"></div>
  <button class="back-btn" onclick="playSound('book'); closeMenuDictSelect()" style="margin-top:30px;">ë’¤ë¡œ</button>
</div>

<!-- MENU DICTIONARY: Card List -->
<div id="menu-dictionary" style="display:none; flex-direction:column; align-items:center; height:100vh; background:linear-gradient(135deg,#0f0c29,#302b63,#24243e); padding:30px; overflow-y:auto;">
  <h2 id="menu-dict-title" style="margin-bottom:20px;">ğŸ“– ì¹´ë“œ ë„ê°</h2>
  <div id="menu-dict-content" style="width:100%; max-width:700px;"></div>
  <button class="back-btn" onclick="playSound('book'); backToMenuDictSelect()" style="margin-top:20px; margin-bottom:30px;">ë’¤ë¡œ</button>
</div>

<!-- FACTION SELECT -->
<div id="faction-select">
  <h2>ì„¸ë ¥ì„ ì„ íƒí•˜ì„¸ìš”</h2>
  <div class="faction-cards">
    <div class="faction-card human" onclick="playSound('gamestart'); selectFaction('human')">
      <div class="faction-icon">âš”ï¸</div>
      <h3>ì¸ê°„</h3>
      <p>ì‹ ì„±í•œ ë§ˆë²•ê³¼ ê¸°ì‚¬ë‹¨ì˜ í˜<br><br>ğŸ›¡ï¸ ì²´ë ¥ 2 íšŒë³µ</p>
    </div>
    <div class="faction-card demon" onclick="playSound('gamestart'); selectFaction('demon')">
      <div class="faction-icon">ğŸ‘¿</div>
      <h3>ì•…ë§ˆ</h3>
      <p>ì§€ì˜¥ì˜ êµ°ë‹¨ê³¼ ì–´ë‘ ì˜ í˜<br><br>ğŸ’€ 1/1 êµ¬ìš¸ ì†Œí™˜</p>
    </div>
    <div class="faction-card elf" onclick="playSound('gamestart'); selectFaction('elf')">
      <div class="faction-icon">ğŸ§</div>
      <h3>ì—˜í”„</h3>
      <p>ìˆ²ì˜ ì •ë°€í•œ ê¶ìˆ ê³¼ ë§ˆë²•<br><br>ğŸ¹ ì ì—ê²Œ 1 ë°ë¯¸ì§€</p>
    </div>
    <div class="faction-card druid" onclick="playSound('gamestart'); selectFaction('druid')">
      <div class="faction-icon">ğŸŒ¿</div>
      <h3>ë“œë£¨ì´ë“œ</h3>
      <p>ìì—°ê³¼ ì•¼ìˆ˜ì˜ ì›ì‹œì  í˜<br><br>ğŸ¿ï¸ 1/1 ë‹¤ëŒì¥ ì†Œí™˜ (ëŒì§„)</p>
    </div>
    <div class="faction-card dwarf" onclick="playSound('gamestart'); selectFaction('dwarf')">
      <div class="faction-icon">â›ï¸</div>
      <h3>ë“œì›Œí”„</h3>
      <p>ê´‘ì‚°ì˜ ê¸°ìˆ ê³¼ ê°•ì² ì˜ í˜<br><br>ğŸ›¡ï¸ ì•„êµ° +1 ì²´ë ¥ ê°•í™”</p>
    </div>
  </div>
  <button class="back-btn" onclick="playSound('click'); showMainMenu()">ë’¤ë¡œ</button>
</div>

<!-- GAME BOARD -->
<div id="game-board">
  <div class="top-bar">
    <span class="game-info" id="turn-info">í„´ 1</span>
    <span class="game-info" id="game-mode-info"></span>
    <span class="menu-link" onclick="openPauseMenu()">ë©”ë‰´</span>
  </div>

  <!-- Opponent area -->
  <div class="player-area opponent">
    <div class="hero-portrait" id="opponent-hero" onclick="targetHero('opponent')">
      <span id="opponent-hero-icon">ğŸ‘¿</span>
      <div class="hero-hp" id="opponent-hp">30</div>
    </div>
    <div class="hero-info">
      <span class="hero-name" id="opponent-name">ì•…ë§ˆ</span>
      <div class="mana-bar" id="opponent-mana-bar"></div>
    </div>
    <div class="hero-power-btn disabled" id="opponent-power-btn">ì˜ì›… ëŠ¥ë ¥</div>
    <div class="deck-count" id="opponent-deck-count">ë±: 27</div>
  </div>

  <div class="hand-area opponent-hand" id="opponent-hand"></div>

  <div class="field-area opponent-field" id="opponent-field"></div>

  <div class="board-divider"></div>
  <button class="end-turn-btn" id="end-turn-btn" onclick="endTurn()">í„´ ì¢…ë£Œ</button>

  <div class="field-area my-field" id="my-field"></div>

  <div class="hand-area" id="my-hand"></div>

  <div class="player-area mine">
    <div class="hero-portrait" id="my-hero" onclick="targetHero('mine')">
      <span id="my-hero-icon">âš”ï¸</span>
      <div class="hero-hp" id="my-hp">30</div>
    </div>
    <div class="hero-info">
      <span class="hero-name" id="my-name">ì¸ê°„</span>
      <div class="mana-bar" id="my-mana-bar"></div>
    </div>
    <button class="hero-power-btn" id="my-power-btn" onclick="useHeroPower()">ì˜ì›… ëŠ¥ë ¥ (2)</button>
    <div class="deck-count" id="my-deck-count" onclick="toggleDeckViewer()">ë±: 27</div>
  </div>

  <!-- Deck Viewer -->
  <div id="deck-viewer">
    <div class="dict-header" style="background:rgba(52,152,219,0.15); border-color:rgba(52,152,219,0.3);">
      <div>
        <h2 id="deck-viewer-title">ë‚¨ì€ ì¹´ë“œ</h2>
        <p class="dict-subtitle" id="deck-viewer-subtitle"></p>
      </div>
      <button class="dict-close-x" onclick="toggleDeckViewer()">âœ•</button>
    </div>
    <div class="dict-body" id="deck-viewer-content"></div>
  </div>

  <div class="log-area" id="game-log"></div>

  <!-- Dictionary toggle + panel -->
  <button class="dict-toggle" id="dict-toggle" onclick="toggleDictionary()">ğŸ“–</button>
  <div id="card-dictionary">
    <div class="dict-header">
      <div>
        <h2 id="dict-title">ì¹´ë“œ ë„ê°</h2>
        <p class="dict-subtitle" id="dict-subtitle"></p>
      </div>
      <button class="dict-close-x" onclick="toggleDictionary()">âœ•</button>
    </div>
    <div class="dict-body" id="dict-content"></div>
  </div>
</div>

<!-- Turn transition (for PVP) -->
<div id="turn-transition">
  <h2 id="transition-text"></h2>
  <p>í™”ë©´ì„ ìƒëŒ€ì—ê²Œ ë„˜ê²¨ì£¼ì„¸ìš”</p>
  <button onclick="confirmTurnTransition()">ì¤€ë¹„ ì™„ë£Œ</button>
</div>

<!-- Pause Menu -->
<div id="pause-menu">
  <h2>ì¼ì‹œì •ì§€</h2>
  <button class="pause-btn" onclick="playSound('click'); closePauseMenu()">ê³„ì†</button>
  <button class="pause-btn" onclick="playSound('click'); openSettings()">ì„¤ì •</button>
  <button class="pause-btn" onclick="playSound('gamestart'); closePauseMenu(); rematch();">ë‹¤ì‹œí•˜ê¸°</button>
  <button class="pause-btn pause-btn-danger" onclick="playSound('click'); closePauseMenu(); showMainMenu();">ë©”ì¸ ë©”ë‰´</button>
</div>

<!-- Settings Menu -->
<div id="settings-menu">
  <h2>ì„¤ì •</h2>
  <div class="settings-row">
    <span>íš¨ê³¼ìŒ</span>
    <label class="toggle-switch">
      <input type="checkbox" id="sfx-toggle" checked onchange="toggleSfx(this.checked)">
      <span class="toggle-slider"></span>
    </label>
  </div>
  <div class="settings-row">
    <span>ìŒëŸ‰</span>
    <input type="range" id="volume-slider" min="0" max="100" value="50" oninput="setVolume(this.value)">
    <span id="volume-label">50%</span>
  </div>
  <button class="pause-btn" onclick="playSound('click'); closeSettings()">ë’¤ë¡œ</button>
</div>

<!-- Game Over -->
<div id="game-over">
  <h2 id="game-over-title"></h2>
  <p class="result-text" id="game-over-text"></p>
  <button onclick="playSound('gamestart'); rematch()">ì¬ëŒ€ì „</button>
  <button onclick="showMainMenu()">ë©”ì¸ ë©”ë‰´</button>
</div>

<!-- Cancel target button -->
<button class="cancel-target" id="cancel-target-btn" onclick="cancelTargeting()">ì·¨ì†Œ (ìš°í´ë¦­)</button>

<!-- Tooltip -->
<div class="card-tooltip" id="card-tooltip">
  <div class="tooltip-name"></div>
  <div class="tooltip-desc"></div>
  <div class="tooltip-stats"></div>
</div>

<!-- SVG for attack arrow -->
<svg class="attack-arrow" id="attack-arrow" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:800;">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c" />
    </marker>
  </defs>
  <line id="arrow-line" class="attack-line" x1="0" y1="0" x2="0" y2="0" marker-end="url(#arrowhead)" />
</svg>

<script>
// ===== SOUND EFFECTS (Web Audio API) =====
let audioCtx = null;
let sfxEnabled = true;
let sfxVolume = 0.5;

function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playSound(type) {
  if (!sfxEnabled) return;
  try {
    const ctx = getAudioCtx();
    const now = ctx.currentTime;
    const vol = sfxVolume;

    switch(type) {
      case 'summon': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.15);
        gain.gain.setValueAtTime(0.2 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.2);
        break;
      }
      case 'attack': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(60, now + 0.15);
        gain.gain.setValueAtTime(0.3 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.15);
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
        const noise = ctx.createBufferSource();
        const ng = ctx.createGain();
        noise.buffer = buf;
        ng.gain.setValueAtTime(0.15 * vol, now);
        ng.gain.linearRampToValueAtTime(0, now + 0.1);
        noise.connect(ng).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.1);
        break;
      }
      case 'spell': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
        gain.gain.setValueAtTime(0.15 * vol, now);
        gain.gain.linearRampToValueAtTime(0.2 * vol, now + 0.1);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.3);
        break;
      }
      case 'heropower': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(350, now);
        osc.frequency.setValueAtTime(500, now + 0.1);
        gain.gain.setValueAtTime(0.12 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.2);
        break;
      }
      case 'death': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.25);
        gain.gain.setValueAtTime(0.2 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.3);
        break;
      }
      case 'endturn': {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(660, now);
        gain.gain.setValueAtTime(0.1 * vol, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now); osc.stop(now + 0.15);
        break;
      }
      case 'victory': {
        const notes = [523, 659, 784, 1047];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, now + i * 0.12);
          gain.gain.setValueAtTime(0.15 * vol, now + i * 0.12);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.12 + 0.25);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.12); osc.stop(now + i * 0.12 + 0.25);
        });
        break;
      }
      case 'defeat': {
        // íŒ¨ë°° - í•˜ê°• ìŠ¬í”ˆ í†¤
        const notes = [400, 350, 300, 200];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + i * 0.15);
          gain.gain.setValueAtTime(0.12 * vol, now + i * 0.15);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.15 + 0.3);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.15); osc.stop(now + i * 0.15 + 0.3);
        });
        break;
      }
      case 'click': {
        // ë¶€ë“œëŸ¬ìš´ "í†¡" - ì§§ì€ ë…¸ì´ì¦ˆ ë²„ìŠ¤íŠ¸ + ì‚´ì§ í†¤
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.04, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
        const noise = ctx.createBufferSource();
        noise.buffer = buf;
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 4000;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.35 * vol, now);
        ng.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
        noise.connect(filter).connect(ng).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.04);
        break;
      }
      case 'book': {
        // ì±… ë„˜ê¸°ëŠ” ì†Œë¦¬ - í•„í„°ë“œ ë…¸ì´ì¦ˆ
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.25, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
        const noise = ctx.createBufferSource();
        noise.buffer = buf;
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(3000, now);
        filter.frequency.linearRampToValueAtTime(1500, now + 0.2);
        filter.Q.value = 0.8;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.3 * vol, now + 0.03);
        gain.gain.linearRampToValueAtTime(0.15 * vol, now + 0.1);
        gain.gain.linearRampToValueAtTime(0, now + 0.25);
        noise.connect(filter).connect(gain).connect(ctx.destination);
        noise.start(now); noise.stop(now + 0.25);
        break;
      }
      case 'gamestart': {
        // ê¸°ëŒ€ê° ìˆëŠ” ìƒìŠ¹ ì•„ë¥´í˜ì§€ì˜¤
        const notes = [330, 440, 554, 659, 880];
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, now + i * 0.08);
          gain.gain.setValueAtTime(0.25 * vol, now + i * 0.08);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.08 + 0.2);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + i * 0.08); osc.stop(now + i * 0.08 + 0.2);
        });
        // ë§ˆë¬´ë¦¬ í™”ìŒ
        [880, 1108, 1320].forEach(freq => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + 0.4);
          gain.gain.setValueAtTime(0.15 * vol, now + 0.4);
          gain.gain.linearRampToValueAtTime(0, now + 0.8);
          osc.connect(gain).connect(ctx.destination);
          osc.start(now + 0.4); osc.stop(now + 0.8);
        });
        break;
      }
    }
  } catch(e) {}
}

// ===== CARD DEFINITIONS =====
const HUMAN_CARDS = [
  // Minions
  { id:'h1', name:'ìˆ˜ë ¨ìƒ', type:'minion', cost:1, attack:1, health:2, emoji:'ğŸ§‘â€ğŸ“', desc:'', keywords:[] },
  { id:'h2', name:'ë¯¼ë³‘ëŒ€', type:'minion', cost:1, attack:2, health:1, emoji:'ğŸ§‘â€ğŸŒ¾', desc:'', keywords:[] },
  { id:'h3', name:'ì„±ê¸°ì‚¬', type:'minion', cost:2, attack:2, health:3, emoji:'ğŸ›¡ï¸', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'h4', name:'ê¶ìˆ˜', type:'minion', cost:2, attack:3, health:1, emoji:'ğŸ¹', desc:'ëŒì§„', keywords:['rush'] },
  { id:'h5', name:'ì¹˜ìœ ì‚¬', type:'minion', cost:2, attack:1, health:3, emoji:'ğŸ’š', desc:'ì „íˆ¬ í•¨ì„±: ì•„êµ° ì˜ì›… ì²´ë ¥ 3 íšŒë³µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); addLog(`ì¹˜ìœ ì‚¬ê°€ ì˜ì›… ì²´ë ¥ì„ 3 íšŒë³µ!`); } },
  { id:'h6', name:'ê¸°ì‚¬', type:'minion', cost:3, attack:3, health:3, emoji:'âš”ï¸', desc:'', keywords:[] },
  { id:'h7', name:'ì„±ì „ì‚¬', type:'minion', cost:3, attack:2, health:4, emoji:'âœï¸', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'h8', name:'ì•”ì‚´ì', type:'minion', cost:3, attack:4, health:2, emoji:'ğŸ—¡ï¸', desc:'ëŒì§„', keywords:['rush'] },
  { id:'h9', name:'ëŒ€ë§ˆë²•ì‚¬', type:'minion', cost:4, attack:3, health:5, emoji:'ğŸ§™', desc:'ì „íˆ¬ í•¨ì„±: ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 2 ë°ë¯¸ì§€', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'h10', name:'ì„±ê¸°ì‚¬ ëŒ€ì¥', type:'minion', cost:4, attack:4, health:4, emoji:'ğŸ°', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'h11', name:'ë¹›ì˜ ìˆ˜í˜¸ì', type:'minion', cost:5, attack:4, health:6, emoji:'ğŸ‘¼', desc:'ìƒëª…ë ¥ í¡ìˆ˜', keywords:['lifesteal'] },
  { id:'h12', name:'ìš©ê¸°ì‚¬', type:'minion', cost:6, attack:5, health:5, emoji:'ğŸ‰', desc:'ëŒì§„', keywords:['rush'] },
  { id:'h13', name:'ëŒ€ì²œì‚¬', type:'minion', cost:7, attack:6, health:7, emoji:'ğŸ˜‡', desc:'ì „íˆ¬ í•¨ì„±: ì•„êµ° ì˜ì›… ì²´ë ¥ 5 íšŒë³µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 5); addLog(`ëŒ€ì²œì‚¬ê°€ ì˜ì›… ì²´ë ¥ì„ 5 íšŒë³µ!`); } },
  // Spells
  { id:'h14', name:'ì‹ ì„±í•œ ë¹›', type:'spell', cost:1, emoji:'âœ¨', desc:'ì•„êµ° ìºë¦­í„° í•˜ë‚˜ì˜ ì²´ë ¥ 4 íšŒë³µ', target:'friendly_any', effect:'heal', value:4 },
  { id:'h15', name:'ì²œë²Œ', type:'spell', cost:3, emoji:'âš¡', desc:'ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 4 ë°ë¯¸ì§€', target:'enemy_minion', effect:'damage', value:4 },
  { id:'h16', name:'ì‹ ì˜ ë¶„ë…¸', type:'spell', cost:5, emoji:'ğŸŒ©ï¸', desc:'ì  ë¯¸ë‹ˆì–¸ ì „ì²´ì—ê²Œ 3 ë°ë¯¸ì§€', target:'none', effect:'aoe_damage', value:3 },
  { id:'h17', name:'ì¶•ë³µ', type:'spell', cost:2, emoji:'ğŸ™', desc:'ì•„êµ° ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const DEMON_CARDS = [
  // Minions
  { id:'d1', name:'ì„í”„', type:'minion', cost:1, attack:2, health:1, emoji:'ğŸ‘¹', desc:'', keywords:[] },
  { id:'d2', name:'ë°•ì¥', type:'minion', cost:1, attack:1, health:2, emoji:'ğŸ¦‡', desc:'', keywords:[] },
  { id:'d3', name:'ì§€ì˜¥ ê°ì‹œì', type:'minion', cost:2, attack:2, health:3, emoji:'ğŸ‘ï¸', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'d4', name:'ê·¸ë¦¼ì ìê°', type:'minion', cost:2, attack:3, health:1, emoji:'ğŸŒ‘', desc:'ëŒì§„', keywords:['rush'] },
  { id:'d5', name:'í¡í˜ˆê·€', type:'minion', cost:2, attack:1, health:3, emoji:'ğŸ§›', desc:'ì „íˆ¬ í•¨ì„±: ì  ì˜ì›…ì—ê²Œ 2 ë°ë¯¸ì§€', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 2; addLog(`í¡í˜ˆê·€ê°€ ì  ì˜ì›…ì—ê²Œ 2 ë°ë¯¸ì§€!`); } },
  { id:'d6', name:'ì„œíë²„ìŠ¤', type:'minion', cost:3, attack:3, health:3, emoji:'ğŸ˜ˆ', desc:'', keywords:[] },
  { id:'d7', name:'ì„ìƒ ìˆ˜í˜¸ì', type:'minion', cost:3, attack:2, health:4, emoji:'ğŸ—¿', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'d8', name:'ì§€ì˜¥ ì‚¬ëƒ¥ê°œ', type:'minion', cost:3, attack:4, health:2, emoji:'ğŸ•â€ğŸ¦º', desc:'ëŒì§„', keywords:['rush'] },
  { id:'d9', name:'ì•…ë§ˆ ë§ˆë²•ì‚¬', type:'minion', cost:4, attack:3, health:5, emoji:'ğŸ”®', desc:'ì „íˆ¬ í•¨ì„±: ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 2 ë°ë¯¸ì§€', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'d10', name:'ì§€ì˜¥ ìˆ˜ë¬¸ì¥', type:'minion', cost:4, attack:4, health:4, emoji:'ğŸšª', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'d11', name:'ì˜í˜¼ í¡ìˆ˜ì', type:'minion', cost:5, attack:4, health:6, emoji:'ğŸ‘»', desc:'ìƒëª…ë ¥ í¡ìˆ˜', keywords:['lifesteal'] },
  { id:'d12', name:'ì§€ì˜¥ë¶ˆ ì •ë ¹', type:'minion', cost:6, attack:5, health:5, emoji:'ğŸ”¥', desc:'ëŒì§„', keywords:['rush'] },
  { id:'d13', name:'ì•…ë§ˆ êµ°ì£¼', type:'minion', cost:7, attack:6, health:7, emoji:'ğŸ‘¿', desc:'ì „íˆ¬ í•¨ì„±: ì  ì˜ì›…ì—ê²Œ 3 ë°ë¯¸ì§€', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 3; addLog(`ì•…ë§ˆ êµ°ì£¼ê°€ ì  ì˜ì›…ì—ê²Œ 3 ë°ë¯¸ì§€!`); } },
  // Spells
  { id:'d14', name:'ì–´ë‘ ì˜ í™”ì‚´', type:'spell', cost:1, emoji:'ğŸ´', desc:'ì  ìºë¦­í„° í•˜ë‚˜ì—ê²Œ 3 ë°ë¯¸ì§€', target:'enemy_any', effect:'damage', value:3 },
  { id:'d15', name:'ì˜í˜¼ ë¶ˆê½ƒ', type:'spell', cost:3, emoji:'ğŸ’€', desc:'ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 4 ë°ë¯¸ì§€', target:'enemy_minion', effect:'damage', value:4 },
  { id:'d16', name:'ì§€ì˜¥ì˜ ë¶ˆê¸¸', type:'spell', cost:5, emoji:'ğŸŒ‹', desc:'ì  ë¯¸ë‹ˆì–¸ ì „ì²´ì—ê²Œ 3 ë°ë¯¸ì§€', target:'none', effect:'aoe_damage', value:3 },
  { id:'d17', name:'ì–´ë‘  ê°•í™”', type:'spell', cost:2, emoji:'ğŸ’ª', desc:'ì•„êµ° ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const ELF_CARDS = [
  // Minions
  { id:'e1', name:'ìš”ì • ì •ì°°ë³‘', type:'minion', cost:1, attack:1, health:2, emoji:'ğŸ§š', desc:'', keywords:[] },
  { id:'e2', name:'ìˆ²ì˜ ê¶ìˆ˜', type:'minion', cost:1, attack:2, health:1, emoji:'ğŸ¹', desc:'', keywords:[] },
  { id:'e3', name:'ë‚˜ë¬´ ë°©íŒ¨ë³‘', type:'minion', cost:2, attack:2, health:3, emoji:'ğŸŒ³', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'e4', name:'ê·¸ë¦¼ì ì‚¬ëƒ¥ê¾¼', type:'minion', cost:2, attack:3, health:1, emoji:'ğŸŒ™', desc:'ëŒì§„', keywords:['rush'] },
  { id:'e5', name:'ë‹¬ë¹› ì¹˜ìœ ì‚¬', type:'minion', cost:2, attack:1, health:3, emoji:'ğŸŒ›', desc:'ì „íˆ¬ í•¨ì„±: ì•„êµ° ì˜ì›… ì²´ë ¥ 3 íšŒë³µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); addLog(`ë‹¬ë¹› ì¹˜ìœ ì‚¬ê°€ ì˜ì›… ì²´ë ¥ì„ 3 íšŒë³µ!`); } },
  { id:'e6', name:'ì—˜í”„ ê²€ì‚¬', type:'minion', cost:3, attack:3, health:3, emoji:'âš”ï¸', desc:'', keywords:[] },
  { id:'e7', name:'ê³ ëŒ€ ìˆ˜í˜¸ì', type:'minion', cost:3, attack:2, health:4, emoji:'ğŸŒ²', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'e8', name:'ë°”ëŒ ì¶”ì ì', type:'minion', cost:3, attack:4, health:2, emoji:'ğŸ’¨', desc:'ëŒì§„', keywords:['rush'] },
  { id:'e9', name:'ë³„ë¹› ë§ˆë²•ì‚¬', type:'minion', cost:4, attack:3, health:5, emoji:'â­', desc:'ì „íˆ¬ í•¨ì„±: ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 2 ë°ë¯¸ì§€', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'e10', name:'ìˆ²ì˜ íŒŒìˆ˜ê¾¼', type:'minion', cost:4, attack:4, health:4, emoji:'ğŸ¦Œ', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'e11', name:'ìƒëª…ì˜ ì •ë ¹', type:'minion', cost:5, attack:4, health:6, emoji:'ğŸƒ', desc:'ìƒëª…ë ¥ í¡ìˆ˜', keywords:['lifesteal'] },
  { id:'e12', name:'ì€ë¹› ìš©ì‚¬', type:'minion', cost:6, attack:5, health:5, emoji:'ğŸ¦…', desc:'ëŒì§„', keywords:['rush'] },
  { id:'e13', name:'ìˆ²ì˜ ì—¬ì™•', type:'minion', cost:7, attack:6, health:7, emoji:'ğŸ‘‘', desc:'ì „íˆ¬ í•¨ì„±: ì•„êµ° ì˜ì›… ì²´ë ¥ 5 íšŒë³µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 5); addLog(`ìˆ²ì˜ ì—¬ì™•ì´ ì˜ì›… ì²´ë ¥ì„ 5 íšŒë³µ!`); } },
  // Spells
  { id:'e14', name:'ë‹¬ë¹› í™”ì‚´', type:'spell', cost:1, emoji:'ğŸ¹', desc:'ì  ìºë¦­í„° í•˜ë‚˜ì—ê²Œ 3 ë°ë¯¸ì§€', target:'enemy_any', effect:'damage', value:3 },
  { id:'e15', name:'ë³„ì˜ ë¶„ë…¸', type:'spell', cost:3, emoji:'ğŸŒŸ', desc:'ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 4 ë°ë¯¸ì§€', target:'enemy_minion', effect:'damage', value:4 },
  { id:'e16', name:'ìì—°ì˜ ì‹¬íŒ', type:'spell', cost:5, emoji:'ğŸŒŠ', desc:'ì  ë¯¸ë‹ˆì–¸ ì „ì²´ì—ê²Œ 3 ë°ë¯¸ì§€', target:'none', effect:'aoe_damage', value:3 },
  { id:'e17', name:'ìˆ²ì˜ ì¶•ë³µ', type:'spell', cost:2, emoji:'ğŸŒ¿', desc:'ì•„êµ° ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const DRUID_CARDS = [
  // Minions
  { id:'dr1', name:'ë‹¤ëŒì¥', type:'minion', cost:1, attack:1, health:2, emoji:'ğŸ¿ï¸', desc:'', keywords:[] },
  { id:'dr2', name:'ë…ë±€', type:'minion', cost:1, attack:2, health:1, emoji:'ğŸ', desc:'', keywords:[] },
  { id:'dr3', name:'ê±°ë¶ì´ ìˆ˜í˜¸ì', type:'minion', cost:2, attack:2, health:3, emoji:'ğŸ¢', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'dr4', name:'ë§¤', type:'minion', cost:2, attack:3, health:1, emoji:'ğŸ¦…', desc:'ëŒì§„', keywords:['rush'] },
  { id:'dr5', name:'ì¹˜ìœ ì˜ ë‚˜ë¬´', type:'minion', cost:2, attack:1, health:3, emoji:'ğŸŒ³', desc:'ì „íˆ¬ í•¨ì„±: ì•„êµ° ì˜ì›… ì²´ë ¥ 3 íšŒë³µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); addLog(`ì¹˜ìœ ì˜ ë‚˜ë¬´ê°€ ì˜ì›… ì²´ë ¥ì„ 3 íšŒë³µ!`); } },
  { id:'dr6', name:'ëŠ‘ëŒ€', type:'minion', cost:3, attack:3, health:3, emoji:'ğŸº', desc:'', keywords:[] },
  { id:'dr7', name:'ë‚˜ë¬´ ì •ë ¹', type:'minion', cost:3, attack:2, health:4, emoji:'ğŸŒ´', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'dr8', name:'ì•¼ìƒ ë©§ë¼ì§€', type:'minion', cost:3, attack:4, health:2, emoji:'ğŸ—', desc:'ëŒì§„', keywords:['rush'] },
  { id:'dr9', name:'ë…ìˆ˜ë¦¬ í˜„ì', type:'minion', cost:4, attack:3, health:5, emoji:'ğŸ¦‰', desc:'ì „íˆ¬ í•¨ì„±: ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 2 ë°ë¯¸ì§€', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'dr10', name:'ê³° ìˆ˜í˜¸ì', type:'minion', cost:4, attack:4, health:4, emoji:'ğŸ»', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'dr11', name:'ë±€íŒŒì´ì–´ ë°•ì¥', type:'minion', cost:5, attack:4, health:6, emoji:'ğŸ¦‡', desc:'ìƒëª…ë ¥ í¡ìˆ˜', keywords:['lifesteal'] },
  { id:'dr12', name:'ëŒì§„ ì½”ë¿”ì†Œ', type:'minion', cost:6, attack:5, health:5, emoji:'ğŸ¦', desc:'ëŒì§„', keywords:['rush'] },
  { id:'dr13', name:'ê³ ëŒ€ ë‚˜ë¬´ì •ë ¹', type:'minion', cost:7, attack:6, health:7, emoji:'ğŸŒ', desc:'ì „íˆ¬ í•¨ì„±: ì  ì˜ì›…ì—ê²Œ 3 ë°ë¯¸ì§€', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 3; addLog(`ê³ ëŒ€ ë‚˜ë¬´ì •ë ¹ì´ ì  ì˜ì›…ì—ê²Œ 3 ë°ë¯¸ì§€!`); } },
  // Spells
  { id:'dr14', name:'ê°€ì‹œ ë©êµ´', type:'spell', cost:1, emoji:'ğŸŒµ', desc:'ì  ìºë¦­í„° í•˜ë‚˜ì—ê²Œ 3 ë°ë¯¸ì§€', target:'enemy_any', effect:'damage', value:3 },
  { id:'dr15', name:'ìì—°ì˜ ë¶„ë…¸', type:'spell', cost:3, emoji:'ğŸ‚', desc:'ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 4 ë°ë¯¸ì§€', target:'enemy_minion', effect:'damage', value:4 },
  { id:'dr16', name:'í­í’ì˜ ëˆˆ', type:'spell', cost:5, emoji:'ğŸŒªï¸', desc:'ì  ë¯¸ë‹ˆì–¸ ì „ì²´ì—ê²Œ 3 ë°ë¯¸ì§€', target:'none', effect:'aoe_damage', value:3 },
  { id:'dr17', name:'ì•¼ìƒì˜ í˜', type:'spell', cost:2, emoji:'ğŸ’ª', desc:'ì•„êµ° ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const DWARF_CARDS = [
  // Minions
  { id:'dw1', name:'ê´‘ë¶€ ê²¬ìŠµìƒ', type:'minion', cost:1, attack:1, health:2, emoji:'â›ï¸', desc:'', keywords:[] },
  { id:'dw2', name:'í™”ì•½ ê¸°ìˆ ì', type:'minion', cost:1, attack:2, health:1, emoji:'ğŸ’£', desc:'', keywords:[] },
  { id:'dw3', name:'ì² ë²½ ìˆ˜ë¹„ë³‘', type:'minion', cost:2, attack:2, health:3, emoji:'ğŸ›¡ï¸', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'dw4', name:'ì¦ê¸° ëŒê²©ë³‘', type:'minion', cost:2, attack:3, health:1, emoji:'ğŸ’¨', desc:'ëŒì§„', keywords:['rush'] },
  { id:'dw5', name:'ìˆ˜ë¦¬ê³µ', type:'minion', cost:2, attack:1, health:3, emoji:'ğŸ”§', desc:'ì „íˆ¬ í•¨ì„±: ì•„êµ° ì˜ì›… ì²´ë ¥ 3 íšŒë³µ', keywords:[], battlecry: (gs, player) => { gs[player].hp = Math.min(30, gs[player].hp + 3); addLog(`ìˆ˜ë¦¬ê³µì´ ì˜ì›… ì²´ë ¥ì„ 3 íšŒë³µ!`); } },
  { id:'dw6', name:'ì² í‡´ ì „ì‚¬', type:'minion', cost:3, attack:3, health:3, emoji:'ğŸ”¨', desc:'', keywords:[] },
  { id:'dw7', name:'ê°•ì²  ê³¨ë ˜', type:'minion', cost:3, attack:2, health:4, emoji:'ğŸ¤–', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'dw8', name:'í­íŒŒë³‘', type:'minion', cost:3, attack:4, health:2, emoji:'ğŸ§¨', desc:'ëŒì§„', keywords:['rush'] },
  { id:'dw9', name:'ëŒ€í¬ ê¸°ìˆ ì', type:'minion', cost:4, attack:3, health:5, emoji:'ğŸ’¥', desc:'ì „íˆ¬ í•¨ì„±: ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 2 ë°ë¯¸ì§€', keywords:[], battlecry_target:'enemy_minion', battlecry_damage:2 },
  { id:'dw10', name:'ë¯¸ìŠ¤ë¦´ ìˆ˜í˜¸ì', type:'minion', cost:4, attack:4, health:4, emoji:'ğŸ°', desc:'ë„ë°œ', keywords:['taunt'] },
  { id:'dw11', name:'ì¦ê¸° í¡ìˆ˜ê¸°', type:'minion', cost:5, attack:4, health:6, emoji:'âš™ï¸', desc:'ìƒëª…ë ¥ í¡ìˆ˜', keywords:['lifesteal'] },
  { id:'dw12', name:'ì „ì°¨', type:'minion', cost:6, attack:5, health:5, emoji:'ğŸš‚', desc:'ëŒì§„', keywords:['rush'] },
  { id:'dw13', name:'ê¸°ê³„ êµ°ì£¼', type:'minion', cost:7, attack:6, health:7, emoji:'ğŸ¦¾', desc:'ì „íˆ¬ í•¨ì„±: ì  ì˜ì›…ì—ê²Œ 3 ë°ë¯¸ì§€', keywords:[], battlecry: (gs, player) => { const opp = player === 'p1' ? 'p2' : 'p1'; gs[opp].hp -= 3; addLog(`ê¸°ê³„ êµ°ì£¼ê°€ ì  ì˜ì›…ì—ê²Œ 3 ë°ë¯¸ì§€!`); } },
  // Spells
  { id:'dw14', name:'í­íƒ„ íˆ¬ì²™', type:'spell', cost:1, emoji:'ğŸ’£', desc:'ì  ìºë¦­í„° í•˜ë‚˜ì—ê²Œ 3 ë°ë¯¸ì§€', target:'enemy_any', effect:'damage', value:3 },
  { id:'dw15', name:'ìš©ì•” ë¶„ì¶œ', type:'spell', cost:3, emoji:'ğŸŒ‹', desc:'ì  ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ 4 ë°ë¯¸ì§€', target:'enemy_minion', effect:'damage', value:4 },
  { id:'dw16', name:'ëŒ€í­ë°œ', type:'spell', cost:5, emoji:'ğŸ”¥', desc:'ì  ë¯¸ë‹ˆì–¸ ì „ì²´ì—ê²Œ 3 ë°ë¯¸ì§€', target:'none', effect:'aoe_damage', value:3 },
  { id:'dw17', name:'ê°•ì²  ê°•í™”', type:'spell', cost:2, emoji:'ğŸ›¡ï¸', desc:'ì•„êµ° ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ +2/+2', target:'friendly_minion', effect:'buff', value:2 },
];

const FACTION_CONFIG = {
  human: { name:'ì¸ê°„', cardClass:'human-card', heroClass:'human-hero', emoji:'âš”ï¸', powerName:'ì„±ìŠ¤ëŸ¬ìš´ íšŒë³µ', powerDesc:'ì˜ì›… ì²´ë ¥ 2 íšŒë³µ', cards: HUMAN_CARDS },
  demon: { name:'ì•…ë§ˆ', cardClass:'demon-card', heroClass:'demon-hero', emoji:'ğŸ‘¿', powerName:'êµ¬ìš¸ ì†Œí™˜', powerDesc:'1/1 êµ¬ìš¸ ì†Œí™˜', cards: DEMON_CARDS },
  elf:   { name:'ì—˜í”„', cardClass:'elf-card', heroClass:'elf-hero', emoji:'ğŸ§', powerName:'ìš”ì •ì˜ í™”ì‚´', powerDesc:'ì  ì˜ì›…ì—ê²Œ 1 ë°ë¯¸ì§€', cards: ELF_CARDS },
  druid: { name:'ë“œë£¨ì´ë“œ', cardClass:'druid-card', heroClass:'druid-hero', emoji:'ğŸŒ¿', powerName:'ì•¼ìƒì˜ ë¶€ë¦„', powerDesc:'1/1 ë‹¤ëŒì¥ ì†Œí™˜ (ëŒì§„)', cards: DRUID_CARDS },
  dwarf: { name:'ë“œì›Œí”„', cardClass:'dwarf-card', heroClass:'dwarf-hero', emoji:'â›ï¸', powerName:'ì¥ê°‘ ê°•í™”', powerDesc:'ì•„êµ° ë¯¸ë‹ˆì–¸ +1 ì²´ë ¥ (ì—†ìœ¼ë©´ ì˜ì›… ì²´ë ¥ 2 íšŒë³µ)', cards: DWARF_CARDS },
};

const COIN_CARD = { id:'coin', name:'ë™ì „', type:'spell', cost:0, emoji:'ğŸª™', desc:'ì´ë²ˆ í„´ ë§ˆë‚˜ 1 íšë“', target:'none', effect:'coin', value:1 };

// ===== GAME STATE =====
let gameState = null;
let gameMode = 'ai'; // 'ai' or 'pvp'
let selectedFaction = 'human';
let selectedAttacker = null;
let targetingSpell = null;
let battlecryTarget = null;
let logs = [];

function createDeck(faction) {
  const cards = FACTION_CONFIG[faction].cards;
  let allCards = [];
  // 2 copies of each card
  cards.forEach(c => {
    allCards.push({...c, uid: Math.random().toString(36).substr(2,9)});
    allCards.push({...c, uid: Math.random().toString(36).substr(2,9)});
  });

  // Group cards by cost tiers
  const tiers = [
    allCards.filter(c => c.cost <= 2),  // ì´ˆë°˜ (1-2 ì½”ìŠ¤íŠ¸)
    allCards.filter(c => c.cost === 3),  // ì¤‘ì´ˆë°˜ (3 ì½”ìŠ¤íŠ¸)
    allCards.filter(c => c.cost === 4),  // ì¤‘ë°˜ (4 ì½”ìŠ¤íŠ¸)
    allCards.filter(c => c.cost >= 5),   // í›„ë°˜ (5+ ì½”ìŠ¤íŠ¸)
  ];

  // Shuffle within each tier
  tiers.forEach(tier => {
    for (let i = tier.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tier[i], tier[j]] = [tier[j], tier[i]];
    }
  });

  // Build deck: high cost at bottom (index 0), low cost on top (end)
  // deck.pop() draws from end, so low cost cards are drawn first
  let deck = [...tiers[3], ...tiers[2], ...tiers[1], ...tiers[0]];

  // Add slight randomness: swap ~20% of adjacent cards to avoid being too predictable
  for (let i = 0; i < deck.length - 1; i++) {
    if (Math.random() < 0.2) {
      [deck[i], deck[i+1]] = [deck[i+1], deck[i]];
    }
  }

  return deck;
}

function initGame() {
  const p1Faction = selectedFaction;
  const otherFactions = Object.keys(FACTION_CONFIG).filter(f => f !== selectedFaction);
  const p2Faction = otherFactions[Math.floor(Math.random() * otherFactions.length)];

  gameState = {
    turn: 1,
    currentPlayer: 'p1',
    p1: {
      faction: p1Faction,
      hp: 30,
      maxMana: 0,
      mana: 0,
      deck: createDeck(p1Faction),
      hand: [],
      field: [],
      heroPowerUsed: false,
    },
    p2: {
      faction: p2Faction,
      hp: 30,
      maxMana: 0,
      mana: 0,
      deck: createDeck(p2Faction),
      hand: [],
      field: [],
      heroPowerUsed: false,
    },
    gameOver: false,
    winner: null,
  };

  // Draw starting hands
  for (let i = 0; i < 3; i++) drawCard('p1');
  for (let i = 0; i < 4; i++) drawCard('p2');

  // P2 gets the coin
  gameState.p2.hand.push({...COIN_CARD, uid: 'coin_' + Math.random().toString(36).substr(2,9)});

  // Start P1's turn
  startTurn('p1');

  logs = [];
  addLog('ê²Œì„ ì‹œì‘!');
  addLog(`${getFactionName(p1Faction)} vs ${getFactionName(p2Faction)}`);
}

function getFactionName(f) { return FACTION_CONFIG[f].name; }
function getFactionClass(f) { return FACTION_CONFIG[f].cardClass; }
function getHeroClass(f) { return FACTION_CONFIG[f].heroClass; }
function getHeroEmoji(f) { return FACTION_CONFIG[f].emoji; }
function getHeroPowerName(f) { return FACTION_CONFIG[f].powerName; }

function drawCard(player) {
  const p = gameState[player];
  if (p.deck.length === 0) {
    // Fatigue damage
    p.fatigue = (p.fatigue || 0) + 1;
    p.hp -= p.fatigue;
    addLog(`${getFactionName(p.faction)}: ë± ì†Œì§„! ${p.fatigue} í”¼ë¡œ ë°ë¯¸ì§€!`);
    checkGameOver();
    return;
  }
  if (p.hand.length >= 10) {
    const burned = p.deck.pop();
    addLog(`${burned.name} ì¹´ë“œê°€ ì†ì´ ê°€ë“ ì°¨ì„œ ë¶ˆíƒ”ìŠµë‹ˆë‹¤!`);
    return;
  }
  p.hand.push(p.deck.pop());
}

function startTurn(player) {
  const p = gameState[player];
  gameState.currentPlayer = player;

  // Increase mana
  if (p.maxMana < 10) p.maxMana++;
  p.mana = p.maxMana;

  // Reset hero power
  p.heroPowerUsed = false;

  // Reset minion attacks
  p.field.forEach(m => {
    m.canAttack = true;
    m.attacksThisTurn = 0;
    m.summonedThisTurn = false;
  });

  // Draw
  drawCard(player);

  clearSelection();
  render();
}

function endTurn() {
  if (gameState.gameOver) return;
  playSound('endturn');

  const current = gameState.currentPlayer;
  const next = current === 'p1' ? 'p2' : 'p1';

  if (current === 'p1' && next === 'p2') {
    // nothing special
  } else {
    gameState.turn++;
  }

  clearSelection();

  if (gameMode === 'pvp') {
    showTurnTransition(next);
  } else {
    startTurn(next);
    if (next === 'p2') {
      // AI turn
      setTimeout(() => aiTurn(), 500);
    }
  }
}

// ===== CARD PLAYING =====
function playCard(cardIndex) {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  if (gameMode === 'ai' && player === 'p2') return; // AI controls p2

  const p = gameState[player];
  const card = p.hand[cardIndex];

  if (!card) return;
  if (card.cost > p.mana) return;

  if (card.type === 'minion') {
    if (p.field.length >= 7) {
      addLog('í•„ë“œê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!');
      return;
    }

    // Check if this minion has a targeted battlecry
    if (card.battlecry_target) {
      const opp = player === 'p1' ? 'p2' : 'p1';
      const targets = gameState[opp].field;
      if (targets.length > 0) {
        // Need to select a target
        battlecryTarget = { cardIndex, card, player };
        highlightTargets(card.battlecry_target, player);
        document.getElementById('cancel-target-btn').style.display = 'block';
        return;
      }
    }

    summonMinion(player, card, cardIndex);

  } else if (card.type === 'spell') {
    if (card.target === 'none') {
      // No target needed
      castSpell(player, card, cardIndex, null, null);
    } else {
      // Need to select target
      targetingSpell = { cardIndex, card, player };
      highlightTargets(card.target, player);
      document.getElementById('cancel-target-btn').style.display = 'block';
    }
  }
}

function summonMinion(player, card, cardIndex) {
  const p = gameState[player];

  p.mana -= card.cost;
  p.hand.splice(cardIndex, 1);

  const minion = {
    ...card,
    uid: card.uid,
    currentHealth: card.health,
    maxHealth: card.health,
    currentAttack: card.attack,
    canAttack: card.keywords.includes('rush'),
    summonedThisTurn: true,
    attacksThisTurn: 0,
  };

  p.field.push(minion);
  addLog(`${card.name} ì†Œí™˜! (${card.attack}/${card.health})`);
  playSound('summon');

  // Execute battlecry
  if (card.battlecry && !card.battlecry_target) {
    card.battlecry(gameState, player);
  }

  checkGameOver();
  render();
}

function executeBattlecry(targetMinion) {
  if (!battlecryTarget) return;

  const { cardIndex, card, player } = battlecryTarget;
  const p = gameState[player];
  const opp = player === 'p1' ? 'p2' : 'p1';

  // Summon first
  summonMinion(player, card, cardIndex);

  // Then deal battlecry damage
  if (card.battlecry_damage) {
    targetMinion.currentHealth -= card.battlecry_damage;
    addLog(`${card.name}ì˜ ì „íˆ¬ í•¨ì„±! ${targetMinion.name}ì—ê²Œ ${card.battlecry_damage} ë°ë¯¸ì§€!`);
    showFloatingText(targetMinion.uid, `-${card.battlecry_damage}`, 'damage');

    // Remove dead minions
    gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
  }

  battlecryTarget = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
  checkGameOver();
  render();
}

function castSpell(player, card, cardIndex, targetType, target) {
  const p = gameState[player];
  const opp = player === 'p1' ? 'p2' : 'p1';

  p.mana -= card.cost;
  p.hand.splice(cardIndex, 1);

  addLog(`${card.name} ì‹œì „!`);
  playSound('spell');

  switch(card.effect) {
    case 'damage':
      if (target === 'hero') {
        gameState[opp].hp -= card.value;
        addLog(`ì  ì˜ì›…ì—ê²Œ ${card.value} ë°ë¯¸ì§€!`);
        showHeroFloatingText(opp, `-${card.value}`, 'damage');
      } else if (target && target.uid) {
        target.currentHealth -= card.value;
        addLog(`${target.name}ì—ê²Œ ${card.value} ë°ë¯¸ì§€!`);
        showFloatingText(target.uid, `-${card.value}`, 'damage');
        // Check if target has poison - doesn't apply to spells
        gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
      }
      break;
    case 'heal':
      if (target === 'hero') {
        const healed = Math.min(card.value, 30 - gameState[player].hp);
        gameState[player].hp = Math.min(30, gameState[player].hp + card.value);
        addLog(`ì˜ì›… ì²´ë ¥ ${healed} íšŒë³µ!`);
        showHeroFloatingText(player, `+${healed}`, 'heal');
      } else if (target && target.uid) {
        const healed = Math.min(card.value, target.maxHealth - target.currentHealth);
        target.currentHealth = Math.min(target.maxHealth, target.currentHealth + card.value);
        addLog(`${target.name} ì²´ë ¥ ${healed} íšŒë³µ!`);
        showFloatingText(target.uid, `+${healed}`, 'heal');
      }
      break;
    case 'aoe_damage':
      gameState[opp].field.forEach(m => {
        m.currentHealth -= card.value;
        showFloatingText(m.uid, `-${card.value}`, 'damage');
      });
      gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);
      addLog(`ì  ë¯¸ë‹ˆì–¸ ì „ì²´ì—ê²Œ ${card.value} ë°ë¯¸ì§€!`);
      break;
    case 'buff':
      if (target && target.uid) {
        target.currentAttack += card.value;
        target.currentHealth += card.value;
        target.maxHealth += card.value;
        addLog(`${target.name}ì—ê²Œ +${card.value}/+${card.value} ê°•í™”!`);
        showFloatingText(target.uid, `+${card.value}/+${card.value}`, 'heal');
      }
      break;
    case 'coin':
      p.mana = Math.min(10, p.mana + 1);
      addLog('ë§ˆë‚˜ 1 íšë“!');
      break;
  }

  targetingSpell = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
  checkGameOver();
  render();
}

// ===== COMBAT =====
function selectAttacker(minion) {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  if (gameMode === 'ai' && player === 'p2') return;

  const p = gameState[player];
  if (!p.field.includes(minion)) return;

  if (!minion.canAttack || minion.attacksThisTurn > 0) return;
  if (minion.summonedThisTurn && !minion.keywords.includes('rush')) return;

  clearSelection();
  selectedAttacker = minion;
  render();
}

function attackTarget(target, targetPlayer) {
  if (!selectedAttacker || gameState.gameOver) return;

  const player = gameState.currentPlayer;
  const opp = player === 'p1' ? 'p2' : 'p1';

  if (targetPlayer !== opp) return;

  // Check taunt
  const hasTaunt = gameState[opp].field.some(m => m.keywords.includes('taunt'));
  if (hasTaunt && target !== 'hero' && !target.keywords.includes('taunt')) {
    addLog('ë„ë°œ ë¯¸ë‹ˆì–¸ì„ ë¨¼ì € ê³µê²©í•´ì•¼ í•©ë‹ˆë‹¤!');
    return;
  }
  if (hasTaunt && target === 'hero') {
    addLog('ë„ë°œ ë¯¸ë‹ˆì–¸ì„ ë¨¼ì € ê³µê²©í•´ì•¼ í•©ë‹ˆë‹¤!');
    return;
  }

  // Rush minions can't attack hero on summon turn
  if (selectedAttacker.summonedThisTurn && selectedAttacker.keywords.includes('rush') && target === 'hero') {
    addLog('ëŒì§„ ë¯¸ë‹ˆì–¸ì€ ì†Œí™˜ëœ í„´ì— ì˜ì›…ì„ ê³µê²©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
    return;
  }

  if (target === 'hero') {
    // Attack hero
    playSound('attack');
    gameState[opp].hp -= selectedAttacker.currentAttack;
    addLog(`${selectedAttacker.name}ì´(ê°€) ì  ì˜ì›…ì„ ê³µê²©! ${selectedAttacker.currentAttack} ë°ë¯¸ì§€!`);
    showHeroFloatingText(opp, `-${selectedAttacker.currentAttack}`, 'damage');

    // Lifesteal
    if (selectedAttacker.keywords.includes('lifesteal')) {
      const healed = Math.min(selectedAttacker.currentAttack, 30 - gameState[player].hp);
      gameState[player].hp = Math.min(30, gameState[player].hp + selectedAttacker.currentAttack);
      addLog(`ìƒëª…ë ¥ í¡ìˆ˜! ${healed} íšŒë³µ!`);
    }

    selectedAttacker.canAttack = false;
    selectedAttacker.attacksThisTurn++;
  } else {
    // Attack minion
    const attacker = selectedAttacker;
    playSound('attack');
    addLog(`${attacker.name}ì´(ê°€) ${target.name}ì„(ë¥¼) ê³µê²©!`);

    // Deal damage
    target.currentHealth -= attacker.currentAttack;
    attacker.currentHealth -= target.currentAttack;

    showFloatingText(target.uid, `-${attacker.currentAttack}`, 'damage');
    showFloatingText(attacker.uid, `-${target.currentAttack}`, 'damage');

    // Poison
    if (attacker.keywords.includes('poison') && target.currentHealth > 0) {
      target.currentHealth = 0;
      addLog(`${target.name}ì´(ê°€) ë…ì— ì˜í•´ ì¦‰ì‚¬!`);
    }
    if (target.keywords.includes('poison') && attacker.currentHealth > 0) {
      attacker.currentHealth = 0;
      addLog(`${attacker.name}ì´(ê°€) ë…ì— ì˜í•´ ì¦‰ì‚¬!`);
    }

    // Lifesteal
    if (attacker.keywords.includes('lifesteal')) {
      const healed = Math.min(attacker.currentAttack, 30 - gameState[player].hp);
      gameState[player].hp = Math.min(30, gameState[player].hp + attacker.currentAttack);
      if (healed > 0) addLog(`ìƒëª…ë ¥ í¡ìˆ˜! ${healed} íšŒë³µ!`);
    }

    // Remove dead minions
    const deadCount = gameState[player].field.filter(m => m.currentHealth <= 0).length +
                      gameState[opp].field.filter(m => m.currentHealth <= 0).length;
    if (deadCount > 0) setTimeout(() => playSound('death'), 100);
    gameState[player].field = gameState[player].field.filter(m => m.currentHealth > 0);
    gameState[opp].field = gameState[opp].field.filter(m => m.currentHealth > 0);

    attacker.canAttack = false;
    attacker.attacksThisTurn++;
  }

  clearSelection();
  checkGameOver();
  render();
}

function targetHero(side) {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  const opp = player === 'p1' ? 'p2' : 'p1';

  // If selecting target for a spell
  if (targetingSpell) {
    const { card, cardIndex } = targetingSpell;
    if (card.target === 'enemy_any' && side === (player === 'p1' ? 'opponent' : 'mine')) {
      castSpell(player, card, cardIndex, 'enemy_hero', 'hero');
    } else if (card.target === 'friendly_any' && side === (player === 'p1' ? 'mine' : 'opponent')) {
      castSpell(player, card, cardIndex, 'friendly_hero', 'hero');
    }
    return;
  }

  // If attacking with a minion
  if (selectedAttacker) {
    const targetPlayer = side === 'opponent' ? (player === 'p1' ? 'p2' : 'p1') : player;
    if (targetPlayer === opp) {
      attackTarget('hero', opp);
    }
  }
}

// ===== HERO POWER =====
function useHeroPower() {
  if (gameState.gameOver) return;
  const player = gameState.currentPlayer;
  if (gameMode === 'ai' && player === 'p2') return;

  const p = gameState[player];
  const opp = player === 'p1' ? 'p2' : 'p1';

  if (p.heroPowerUsed || p.mana < 2) return;

  p.mana -= 2;
  p.heroPowerUsed = true;
  playSound('heropower');

  executeHeroPower(p, player, opp, false);

  checkGameOver();
  render();
}

function executeHeroPower(p, player, opp, isAI) {
  const faction = p.faction;
  const oppState = gameState[opp];

  if (faction === 'human') {
    // ì„±ìŠ¤ëŸ¬ìš´ íšŒë³µ: ì˜ì›… ì²´ë ¥ 2 íšŒë³µ
    p.hp = Math.min(30, p.hp + 2);
    addLog(`${getFactionName(faction)} ì˜ì›…ì´ ì²´ë ¥ì„ 2 íšŒë³µ! (${p.hp}/30)`);

  } else if (faction === 'demon') {
    // êµ¬ìš¸ ì†Œí™˜: 1/1 êµ¬ìš¸ ì†Œí™˜
    if (p.field.length < 7) {
      const ghoul = {
        id: 'ghoul_token', name: 'êµ¬ìš¸', type: 'minion', cost: 0,
        attack: 1, health: 1, emoji: 'ğŸ’€', desc: 'ì˜ì›… ëŠ¥ë ¥ìœ¼ë¡œ ì†Œí™˜ë¨',
        keywords: [],
        uid: Date.now() + Math.random(),
        currentHealth: 1, maxHealth: 1, currentAttack: 1,
        canAttack: false, summonedThisTurn: true, attacksThisTurn: 0,
      };
      p.field.push(ghoul);
      addLog(`êµ¬ìš¸ ì†Œí™˜! (1/1)`);
      playSound('summon');
    } else {
      addLog(`í•„ë“œê°€ ê°€ë“ ì°¨ì„œ êµ¬ìš¸ì„ ì†Œí™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`);
    }

  } else if (faction === 'elf') {
    // ìš”ì •ì˜ í™”ì‚´: ì  ì˜ì›…ì—ê²Œ 1 ë°ë¯¸ì§€
    oppState.hp -= 1;
    addLog(`ìš”ì •ì˜ í™”ì‚´! ì  ì˜ì›…ì—ê²Œ 1 ë°ë¯¸ì§€! (${oppState.hp}/30)`);

  } else if (faction === 'druid') {
    // ì•¼ìƒì˜ ë¶€ë¦„: 1/1 ë‹¤ëŒì¥ ì†Œí™˜ (ëŒì§„)
    if (p.field.length < 7) {
      const squirrel = {
        id: 'squirrel_token', name: 'ë‹¤ëŒì¥', type: 'minion', cost: 0,
        attack: 1, health: 1, emoji: 'ğŸ¿ï¸', desc: 'ëŒì§„',
        keywords: ['rush'],
        uid: Date.now() + Math.random(),
        currentHealth: 1, maxHealth: 1, currentAttack: 1,
        canAttack: true, summonedThisTurn: true, attacksThisTurn: 0,
      };
      p.field.push(squirrel);
      addLog(`ë‹¤ëŒì¥ ì†Œí™˜! (1/1) - ëŒì§„`);
      playSound('summon');
    } else {
      addLog(`í•„ë“œê°€ ê°€ë“ ì°¨ì„œ ë‹¤ëŒì¥ë¥¼ ì†Œí™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`);
    }

  } else if (faction === 'dwarf') {
    // ì¥ê°‘ ê°•í™”: ì•„êµ° ë¯¸ë‹ˆì–¸ í•˜ë‚˜ì—ê²Œ +1 ì²´ë ¥, ì—†ìœ¼ë©´ ì˜ì›… ë°©ì–´ë„ 2
    if (p.field.length > 0) {
      if (isAI) {
        // AI: ê°€ì¥ ê³µê²©ë ¥ ë†’ì€ ë¯¸ë‹ˆì–¸ì—ê²Œ ì²´ë ¥ ë¶€ì—¬
        const target = p.field.sort((a, b) => b.currentAttack - a.currentAttack)[0];
        target.currentHealth += 1;
        target.maxHealth += 1;
        addLog(`ì¥ê°‘ ê°•í™”! ${target.name}ì˜ ì²´ë ¥ +1! (${target.currentAttack}/${target.currentHealth})`);
      } else {
        // í”Œë ˆì´ì–´: ìë™ìœ¼ë¡œ ê°€ì¥ ì²´ë ¥ ë‚®ì€ ë¯¸ë‹ˆì–¸ì—ê²Œ ë¶€ì—¬ (íƒ€ê²ŸíŒ… ì—†ì´ ê°„ë‹¨ ì²˜ë¦¬)
        const target = p.field.sort((a, b) => a.currentHealth - b.currentHealth)[0];
        target.currentHealth += 1;
        target.maxHealth += 1;
        addLog(`ì¥ê°‘ ê°•í™”! ${target.name}ì˜ ì²´ë ¥ +1! (${target.currentAttack}/${target.currentHealth})`);
      }
    } else {
      // ë¯¸ë‹ˆì–¸ì´ ì—†ìœ¼ë©´ ì˜ì›… ë°©ì–´ë„ 2
      p.hp = Math.min(30, p.hp + 2);
      addLog(`ì¥ê°‘ ê°•í™”! ë¯¸ë‹ˆì–¸ì´ ì—†ì–´ ì˜ì›… ì²´ë ¥ 2 íšŒë³µ! (${p.hp}/30)`);
    }
  }
}

// ===== TARGETING =====
function highlightTargets(targetType, player) {
  const opp = player === 'p1' ? 'p2' : 'p1';
  render(); // re-render to show targeting state
}

function cancelTargeting() {
  targetingSpell = null;
  battlecryTarget = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
  clearSelection();
  render();
}

function clearSelection() {
  selectedAttacker = null;
  targetingSpell = null;
  battlecryTarget = null;
  document.getElementById('cancel-target-btn').style.display = 'none';
}

// ===== GAME OVER =====
function checkGameOver() {
  if (gameState.p1.hp <= 0) {
    gameState.gameOver = true;
    gameState.winner = 'p2';
    setTimeout(() => showGameOver(), 500);
  } else if (gameState.p2.hp <= 0) {
    gameState.gameOver = true;
    gameState.winner = 'p1';
    setTimeout(() => showGameOver(), 500);
  }
}

function showGameOver() {
  const overlay = document.getElementById('game-over');
  const title = document.getElementById('game-over-title');
  const text = document.getElementById('game-over-text');

  if (gameMode === 'ai') {
    if (gameState.winner === 'p1') {
      title.textContent = 'ìŠ¹ë¦¬!';
      title.style.color = '#f1c40f';
      text.textContent = 'ì  ì˜ì›…ì„ ì“°ëŸ¬ëœ¨ë ¸ìŠµë‹ˆë‹¤!';
      playSound('victory');
    } else {
      title.textContent = 'íŒ¨ë°°...';
      title.style.color = '#e74c3c';
      text.textContent = 'ì˜ì›…ì´ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤...';
      playSound('defeat');
    }
  } else {
    const winFaction = gameState[gameState.winner].faction;
    title.textContent = `${getFactionName(winFaction)} ìŠ¹ë¦¬!`;
    title.style.color = '#f1c40f';
    text.textContent = `${getFactionName(winFaction)} ì§„ì˜ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`;
    playSound('victory');
  }

  overlay.style.display = 'flex';
}

// ===== PVP TURN TRANSITION =====
function showTurnTransition(nextPlayer) {
  const overlay = document.getElementById('turn-transition');
  const text = document.getElementById('transition-text');
  const faction = gameState[nextPlayer].faction;
  text.textContent = `${getFactionName(faction)} í”Œë ˆì´ì–´ ì°¨ë¡€`;
  overlay.style.display = 'flex';
}

function confirmTurnTransition() {
  document.getElementById('turn-transition').style.display = 'none';
  const next = gameState.currentPlayer === 'p1' ? 'p2' : 'p1';
  startTurn(next);
}

// ===== AI =====
function aiTurn() {
  if (gameState.gameOver || gameState.currentPlayer !== 'p2') return;

  const p = gameState.p2;
  const opp = gameState.p1;

  // Simple AI: play cards, attack, use hero power
  let actions = [];

  // 1. Play cards (sorted by cost descending for efficiency)
  let playableCards = p.hand
    .map((c, i) => ({card: c, index: i}))
    .filter(({card}) => card.cost <= p.mana)
    .sort((a, b) => b.card.cost - a.card.cost);

  for (const {card, index} of playableCards) {
    if (card.cost > p.mana) continue;

    if (card.type === 'minion' && p.field.length < 7) {
      // Play minion
      if (card.battlecry_target === 'enemy_minion' && opp.field.length > 0) {
        // Find best target for battlecry
        const target = opp.field.reduce((best, m) => {
          if (m.currentHealth <= card.battlecry_damage) return m; // Kill target
          return best || m;
        }, null) || opp.field[0];

        const ci = p.hand.indexOf(card);
        if (ci >= 0) {
          summonMinion('p2', card, ci);
          if (target) {
            target.currentHealth -= card.battlecry_damage;
            addLog(`${card.name}ì˜ ì „íˆ¬ í•¨ì„±! ${target.name}ì—ê²Œ ${card.battlecry_damage} ë°ë¯¸ì§€!`);
            opp.field = opp.field.filter(m => m.currentHealth > 0);
          }
        }
      } else {
        const ci = p.hand.indexOf(card);
        if (ci >= 0) summonMinion('p2', card, ci);
      }
    } else if (card.type === 'spell') {
      const ci = p.hand.indexOf(card);
      if (ci < 0) continue;

      if (card.effect === 'aoe_damage') {
        if (opp.field.length >= 2) {
          castSpell('p2', card, ci, null, null);
        }
      } else if (card.effect === 'damage') {
        if (card.target === 'enemy_minion' && opp.field.length > 0) {
          // Target highest health minion that can be killed, or highest attack
          const target = opp.field.sort((a, b) => {
            if (a.currentHealth <= card.value && b.currentHealth > card.value) return -1;
            if (b.currentHealth <= card.value && a.currentHealth > card.value) return 1;
            return b.currentAttack - a.currentAttack;
          })[0];
          castSpell('p2', card, ci, 'minion', target);
        } else if (card.target === 'enemy_any') {
          // Prefer killing minions, otherwise go face
          const killable = opp.field.find(m => m.currentHealth <= card.value);
          if (killable) {
            castSpell('p2', card, ci, 'minion', killable);
          } else if (opp.hp <= card.value) {
            castSpell('p2', card, ci, 'hero', 'hero');
          } else if (opp.field.length > 0) {
            castSpell('p2', card, ci, 'minion', opp.field.sort((a, b) => b.currentAttack - a.currentAttack)[0]);
          } else {
            castSpell('p2', card, ci, 'hero', 'hero');
          }
        }
      } else if (card.effect === 'buff' && p.field.length > 0) {
        const target = p.field.sort((a, b) => b.currentAttack - a.currentAttack)[0];
        castSpell('p2', card, ci, 'minion', target);
      } else if (card.effect === 'heal') {
        if (p.hp < 20 && card.target === 'friendly_any') {
          castSpell('p2', card, ci, 'hero', 'hero');
        }
      } else if (card.effect === 'coin') {
        if (p.mana < p.maxMana) {
          castSpell('p2', card, ci, null, null);
        }
      }
    }

    // Recalculate after each card played
    render();
  }

  // 2. Use hero power if possible
  if (!p.heroPowerUsed && p.mana >= 2) {
    p.mana -= 2;
    p.heroPowerUsed = true;
    executeHeroPower(p, 'p2', 'p1', true);
    checkGameOver();
    render();
  }

  // 3. Attack with minions
  setTimeout(() => {
    aiAttack();
  }, 300);
}

function aiAttack() {
  if (gameState.gameOver) return;

  const p = gameState.p2;
  const opp = gameState.p1;

  const attackers = p.field.filter(m => {
    if (m.attacksThisTurn > 0) return false;
    if (m.summonedThisTurn && !m.keywords.includes('rush')) return false;
    return true;
  });

  const hasTaunt = opp.field.some(m => m.keywords.includes('taunt'));

  for (const attacker of attackers) {
    if (gameState.gameOver) break;

    selectedAttacker = attacker;

    if (hasTaunt) {
      const tauntMinions = opp.field.filter(m => m.keywords.includes('taunt'));
      if (tauntMinions.length > 0) {
        // Attack taunt minion with best trade
        const target = tauntMinions.sort((a, b) => {
          const aTradeValue = (a.currentHealth <= attacker.currentAttack ? a.currentAttack : 0);
          const bTradeValue = (b.currentHealth <= attacker.currentAttack ? b.currentAttack : 0);
          return bTradeValue - aTradeValue;
        })[0];
        attackTarget(target, 'p1');
        continue;
      }
    }

    // Check for lethal
    if (opp.hp <= attacker.currentAttack && !(attacker.summonedThisTurn && attacker.keywords.includes('rush'))) {
      attackTarget('hero', 'p1');
      continue;
    }

    // Look for favorable trades
    const killable = opp.field.filter(m => m.currentHealth <= attacker.currentAttack)
      .sort((a, b) => b.currentAttack - a.currentAttack);

    if (killable.length > 0 && killable[0].currentAttack < attacker.currentHealth) {
      attackTarget(killable[0], 'p1');
      continue;
    }

    // If rush minion, must attack minion
    if (attacker.summonedThisTurn && attacker.keywords.includes('rush')) {
      if (opp.field.length > 0) {
        const target = opp.field.sort((a, b) => b.currentAttack - a.currentAttack)[0];
        attackTarget(target, 'p1');
      }
      continue;
    }

    // Go face
    if (opp.field.length === 0 || attacker.currentAttack >= 3) {
      attackTarget('hero', 'p1');
    } else if (opp.field.length > 0) {
      const target = opp.field.sort((a, b) => b.currentAttack - a.currentAttack)[0];
      attackTarget(target, 'p1');
    }
  }

  selectedAttacker = null;

  setTimeout(() => {
    if (!gameState.gameOver) {
      endTurn();
    }
  }, 300);
}

// ===== RENDERING =====
function render() {
  if (!gameState) return;

  const player = gameState.currentPlayer;
  const isP1View = gameMode === 'ai' || player === 'p1';

  const myKey = isP1View ? 'p1' : 'p2';
  const oppKey = isP1View ? 'p2' : 'p1';
  const my = gameState[myKey];
  const opp = gameState[oppKey];

  // Turn info
  document.getElementById('turn-info').textContent = `í„´ ${gameState.turn}`;
  document.getElementById('game-mode-info').textContent =
    gameMode === 'ai' ? 'AI ëŒ€ì „' : `2ì¸ ëŒ€ì „ - ${getFactionName(gameState[player].faction)} ì°¨ë¡€`;

  // Hero portraits
  const myHero = document.getElementById('my-hero');
  const oppHero = document.getElementById('opponent-hero');
  myHero.className = `hero-portrait ${getHeroClass(my.faction)}`;
  oppHero.className = `hero-portrait ${getHeroClass(opp.faction)}`;

  document.getElementById('my-hero-icon').textContent = getHeroEmoji(my.faction);
  document.getElementById('opponent-hero-icon').textContent = getHeroEmoji(opp.faction);
  document.getElementById('my-hp').textContent = my.hp;
  document.getElementById('opponent-hp').textContent = opp.hp;
  document.getElementById('my-name').textContent = getFactionName(my.faction);
  document.getElementById('opponent-name').textContent = getFactionName(opp.faction);

  // HP color
  document.getElementById('my-hp').style.background = my.hp <= 10 ? '#e74c3c' : '#c0392b';
  document.getElementById('opponent-hp').style.background = opp.hp <= 10 ? '#e74c3c' : '#c0392b';

  // Mana bars
  renderManaBar('my-mana-bar', my);
  renderManaBar('opponent-mana-bar', opp);

  // Deck counts
  document.getElementById('my-deck-count').textContent = `ë±: ${my.deck.length}`;
  document.getElementById('opponent-deck-count').textContent = `ë±: ${opp.deck.length}`;

  // Hero power buttons
  const myPowerBtn = document.getElementById('my-power-btn');
  const oppPowerBtn = document.getElementById('opponent-power-btn');

  const isMyTurn = (gameMode === 'ai' && player === 'p1' && myKey === 'p1') ||
                   (gameMode === 'pvp' && myKey === player);

  myPowerBtn.textContent = `${getHeroPowerName(my.faction)} (2)`;
  myPowerBtn.onmouseenter = (e) => showHeroPowerTooltip(my.faction, e);
  myPowerBtn.onmouseleave = () => hideTooltip();
  if (my.heroPowerUsed) {
    myPowerBtn.className = 'hero-power-btn used';
  } else if (my.mana < 2 || !isMyTurn) {
    myPowerBtn.className = 'hero-power-btn disabled';
  } else {
    myPowerBtn.className = 'hero-power-btn';
  }

  oppPowerBtn.textContent = `${getHeroPowerName(opp.faction)} (2)`;
  oppPowerBtn.onmouseenter = (e) => showHeroPowerTooltip(opp.faction, e);
  oppPowerBtn.onmouseleave = () => hideTooltip();
  oppPowerBtn.className = 'hero-power-btn disabled';

  // End turn button
  const endBtn = document.getElementById('end-turn-btn');
  if (gameMode === 'ai' && player === 'p2') {
    endBtn.className = 'end-turn-btn disabled';
    endBtn.textContent = 'ìƒëŒ€ í„´...';
  } else {
    endBtn.className = 'end-turn-btn';
    endBtn.textContent = 'í„´ ì¢…ë£Œ';
  }

  // Opponent hero targetable?
  if (selectedAttacker || (targetingSpell && (targetingSpell.card.target === 'enemy_any'))) {
    oppHero.classList.add('targetable');
  } else {
    oppHero.classList.remove('targetable');
  }

  // Render hands
  renderHand('my-hand', my, myKey, true);
  renderHand('opponent-hand', opp, oppKey, false);

  // Render fields
  renderField('my-field', my, myKey, true);
  renderField('opponent-field', opp, oppKey, false);

  // Log
  renderLog();
}

function renderManaBar(elementId, p) {
  const bar = document.getElementById(elementId);
  let html = '';
  for (let i = 0; i < p.maxMana; i++) {
    html += `<div class="mana-crystal ${i < p.mana ? 'filled' : ''}"></div>`;
  }
  html += `<span class="mana-text">${p.mana}/${p.maxMana}</span>`;
  bar.innerHTML = html;
}

function renderHand(elementId, p, playerKey, isMine) {
  const hand = document.getElementById(elementId);
  hand.innerHTML = '';

  if (!isMine) {
    // Show card backs
    for (let i = 0; i < p.hand.length; i++) {
      const back = document.createElement('div');
      back.className = 'card-back';
      back.textContent = 'ğŸ‚ ';
      hand.appendChild(back);
    }
    return;
  }

  const isCurrentPlayer = gameState.currentPlayer === playerKey;

  p.hand.forEach((card, i) => {
    const el = document.createElement('div');
    const factionClass = card.id === 'coin' ? 'coin-card' : getFactionClass(p.faction);
    const playable = isCurrentPlayer && card.cost <= p.mana && (card.type !== 'minion' || p.field.length < 7);

    el.className = `card in-hand ${factionClass} ${card.type === 'spell' ? 'spell-card' : ''} ${playable ? 'playable' : ''}`;

    el.innerHTML = `
      <div class="card-mana">${card.cost}</div>
      <div class="card-art">${card.emoji}</div>
      <div class="card-name">${card.name}</div>
      <div class="card-desc">${card.desc || ''}</div>
      ${card.type === 'minion' ? `
        <div class="card-stats">
          <div class="card-attack">${card.attack}</div>
          <div class="card-health">${card.health}</div>
        </div>
      ` : '<div class="card-stats"></div>'}
    `;

    if (playable && isCurrentPlayer) {
      el.onclick = () => playCard(i);
    }

    // Tooltip on hover
    el.onmouseenter = (e) => showTooltip(card, e);
    el.onmouseleave = () => hideTooltip();

    hand.appendChild(el);
  });
}

function renderField(elementId, p, playerKey, isMine) {
  const field = document.getElementById(elementId);
  field.innerHTML = '';

  const currentPlayer = gameState.currentPlayer;
  const isMyTurn = currentPlayer === playerKey;
  const opp = playerKey === 'p1' ? 'p2' : 'p1';

  p.field.forEach(m => {
    const el = document.createElement('div');
    const factionClass = getFactionClass(p.faction);

    let canAtk = isMine && isMyTurn && m.attacksThisTurn === 0 &&
      (!m.summonedThisTurn || m.keywords.includes('rush'));

    // For AI mode, only P1 can control
    if (gameMode === 'ai' && playerKey === 'p2') canAtk = false;

    const isSelected = selectedAttacker && selectedAttacker.uid === m.uid;
    const isTargetable = !isMine && (selectedAttacker || targetingSpell || battlecryTarget);

    el.className = `field-minion ${factionClass} ${canAtk ? 'can-attack' : ''} ${m.keywords.includes('taunt') ? 'taunt' : ''} ${isSelected ? 'selected' : ''} ${isTargetable ? 'targetable' : ''}`;

    const keywordText = m.keywords.filter(k => k !== '').map(k => {
      switch(k) {
        case 'taunt': return 'ë„ë°œ';
        case 'rush': return 'ëŒì§„';
        case 'poison': return 'ë…';
        case 'lifesteal': return 'í¡ìˆ˜';
        default: return k;
      }
    }).join(' ');

    const healthDamaged = m.currentHealth < m.maxHealth;

    el.innerHTML = `
      <div class="minion-art">${m.emoji}</div>
      <div class="minion-name">${m.name}</div>
      <div class="minion-keywords">${keywordText}</div>
      <div class="minion-stats">
        <div class="minion-attack">${m.currentAttack}</div>
        <div class="minion-health ${healthDamaged ? 'damaged' : ''}">${m.currentHealth}</div>
      </div>
    `;

    el.dataset.uid = m.uid;

    if (isMine && targetingSpell) {
      const spell = targetingSpell.card;
      if (spell.target === 'friendly_minion' || spell.target === 'friendly_any') {
        el.classList.add('targetable');
        el.onclick = () => {
          castSpell(targetingSpell.player, spell, targetingSpell.cardIndex, 'minion', m);
        };
      }
    } else if (!isMine && targetingSpell) {
      const spell = targetingSpell.card;
      if (spell.target === 'enemy_minion' || spell.target === 'enemy_any') {
        el.onclick = () => {
          castSpell(targetingSpell.player, spell, targetingSpell.cardIndex, 'minion', m);
        };
      }
    } else if (!isMine && battlecryTarget) {
      el.onclick = () => executeBattlecry(m);
    } else if (isMine && canAtk) {
      el.onclick = () => selectAttacker(m);
    } else if (!isMine && selectedAttacker) {
      el.onclick = () => attackTarget(m, playerKey);
    }

    el.onmouseenter = (e) => showTooltip(m, e);
    el.onmouseleave = () => hideTooltip();

    field.appendChild(el);
  });
}

function renderLog() {
  const logArea = document.getElementById('game-log');
  logArea.innerHTML = logs.slice(-15).map(l => `<div class="log-entry">${l}</div>`).join('');
  logArea.scrollTop = logArea.scrollHeight;
}

// ===== FLOATING TEXT =====
function showFloatingText(uid, text, type) {
  const el = document.querySelector(`[data-uid="${uid}"]`);
  if (!el) return;

  const rect = el.getBoundingClientRect();
  const ft = document.createElement('div');
  ft.className = `floating-text ${type}`;
  ft.textContent = text;
  ft.style.left = (rect.left + rect.width/2 - 10) + 'px';
  ft.style.top = (rect.top + rect.height/2 - 10) + 'px';
  document.body.appendChild(ft);

  el.classList.add(type === 'damage' ? 'damage-flash' : 'heal-flash');
  setTimeout(() => {
    el.classList.remove('damage-flash', 'heal-flash');
  }, 300);

  setTimeout(() => ft.remove(), 1000);
}

function showHeroFloatingText(player, text, type) {
  const isP1View = gameMode === 'ai' || gameState.currentPlayer === 'p1';
  const heroId = (player === 'p1') === isP1View ? 'my-hero' : 'opponent-hero';
  const el = document.getElementById(heroId);
  if (!el) return;

  const rect = el.getBoundingClientRect();
  const ft = document.createElement('div');
  ft.className = `floating-text ${type}`;
  ft.textContent = text;
  ft.style.left = (rect.left + rect.width/2 - 10) + 'px';
  ft.style.top = (rect.top) + 'px';
  document.body.appendChild(ft);

  setTimeout(() => ft.remove(), 1000);
}

// ===== TOOLTIP =====
function showTooltip(card, e) {
  const tooltip = document.getElementById('card-tooltip');
  tooltip.querySelector('.tooltip-name').textContent = card.name;
  tooltip.querySelector('.tooltip-desc').textContent = card.desc || 'ì¼ë°˜ ë¯¸ë‹ˆì–¸';

  let stats = '';
  if (card.type === 'minion') {
    const atk = card.currentAttack !== undefined ? card.currentAttack : card.attack;
    const hp = card.currentHealth !== undefined ? card.currentHealth : card.health;
    stats = `ê³µê²©ë ¥: ${atk} | ì²´ë ¥: ${hp} | ë§ˆë‚˜: ${card.cost}`;
  } else {
    stats = `ë§ˆë‚˜: ${card.cost} | ì£¼ë¬¸`;
  }
  tooltip.querySelector('.tooltip-stats').textContent = stats;

  tooltip.style.display = 'block';
  tooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 220) + 'px';
  tooltip.style.top = Math.min(e.clientY + 10, window.innerHeight - 100) + 'px';
}

function showHeroPowerTooltip(faction, e) {
  const cfg = FACTION_CONFIG[faction];
  const tooltip = document.getElementById('card-tooltip');
  tooltip.querySelector('.tooltip-name').textContent = cfg.powerName;
  tooltip.querySelector('.tooltip-desc').textContent = cfg.powerDesc;
  tooltip.querySelector('.tooltip-stats').textContent = '';
  tooltip.style.display = 'block';
  tooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 220) + 'px';
  tooltip.style.top = Math.min(e.clientY + 10, window.innerHeight - 100) + 'px';
}

function hideTooltip() {
  document.getElementById('card-tooltip').style.display = 'none';
}

// ===== LOGGING =====
function addLog(msg) {
  logs.push(msg);
  if (logs.length > 50) logs.shift();
}

// ===== MENU NAVIGATION =====
// ===== PAUSE MENU =====
function openPauseMenu() {
  document.getElementById('pause-menu').style.display = 'flex';
}

function closePauseMenu() {
  document.getElementById('pause-menu').style.display = 'none';
}

function openSettings() {
  document.getElementById('pause-menu').style.display = 'none';
  document.getElementById('settings-menu').style.display = 'flex';
  syncSettingsUI();
}

function closeSettings() {
  document.getElementById('settings-menu').style.display = 'none';
  document.getElementById('pause-menu').style.display = 'flex';
}

function showMainMenu() {
  document.getElementById('main-menu').style.display = 'flex';
  document.getElementById('faction-select').style.display = 'none';
  document.getElementById('game-board').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('turn-transition').style.display = 'none';
  document.getElementById('menu-dictionary').style.display = 'none';
  document.getElementById('pause-menu').style.display = 'none';
  document.getElementById('settings-menu').style.display = 'none';
  document.getElementById('menu-settings').style.display = 'none';
  gameState = null;
}

function startGame(mode) {
  gameMode = mode;
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('faction-select').style.display = 'flex';
}

function selectFaction(faction) {
  selectedFaction = faction;
  document.getElementById('faction-select').style.display = 'none';
  document.getElementById('game-board').style.display = 'flex';
  initGame();
}

function rematch() {
  document.getElementById('game-over').style.display = 'none';
  initGame();
}

// Right click to cancel
document.addEventListener('contextmenu', (e) => {
  if (selectedAttacker || targetingSpell || battlecryTarget) {
    e.preventDefault();
    cancelTargeting();
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    // ë©”ë‰´ ë„ê°: ì¹´ë“œ ëª©ë¡ â†’ ì§„ì˜ ì„ íƒ
    const menuDict = document.getElementById('menu-dictionary');
    if (menuDict.style.display === 'flex') {
      playSound('book'); backToMenuDictSelect(); return;
    }
    // ë©”ë‰´ ë„ê°: ì§„ì˜ ì„ íƒ â†’ ë©”ì¸ ë©”ë‰´
    const menuDictSelect = document.getElementById('menu-dict-select');
    if (menuDictSelect.style.display === 'flex') {
      playSound('book'); closeMenuDictSelect(); return;
    }

    // ê²Œì„ ë‚´ ESC
    const gameBoard = document.getElementById('game-board');
    if (gameBoard.style.display !== 'flex') return;
    const settings = document.getElementById('settings-menu');
    if (settings.style.display === 'flex') {
      closeSettings();
    } else {
      const pause = document.getElementById('pause-menu');
      if (pause.style.display === 'flex') {
        closePauseMenu();
      } else {
        openPauseMenu();
      }
    }
  }
});

// ===== DECK VIEWER =====
function toggleDeckViewer() {
  playSound('book');
  const viewer = document.getElementById('deck-viewer');
  if (viewer.style.display === 'flex') {
    viewer.style.display = 'none';
  } else {
    openDeckViewer();
  }
}

function openDeckViewer() {
  if (!gameState) return;
  const myKey = (gameMode === 'ai' || gameState.currentPlayer === 'p1') ? 'p1' : 'p2';
  const my = gameState[myKey];
  const remaining = [...my.deck].sort((a, b) => a.cost - b.cost || a.name.localeCompare(b.name));

  document.getElementById('deck-viewer-subtitle').textContent = `${remaining.length}ì¥ ë‚¨ìŒ`;

  const fclass = getFactionClass(my.faction);
  let html = '<div class="dict-grid">';
  remaining.forEach(c => {
    if (c.type === 'minion') {
      const kwText = (c.keywords || []).map(k => {
        switch(k) { case 'taunt': return 'ë„ë°œ'; case 'rush': return 'ëŒì§„'; case 'poison': return 'ë…'; case 'lifesteal': return 'í¡ìˆ˜'; default: return k; }
      }).join(', ');
      const desc = c.desc || kwText || '';
      html += `
        <div class="dict-card ${fclass}">
          <div class="dc-left">
            <div class="dc-emoji">${c.emoji}</div>
            <div class="dc-mana">${c.cost}</div>
          </div>
          <div class="dc-right">
            <div class="dc-name">${c.name}</div>
            <div class="dc-desc">${desc}</div>
            <div class="dc-stats"><div class="dc-atk">${c.attack}</div><div class="dc-hp">${c.health}</div></div>
          </div>
        </div>`;
    } else {
      html += `
        <div class="dict-card ${fclass}">
          <div class="dc-left">
            <div class="dc-emoji">${c.emoji}</div>
            <div class="dc-mana">${c.cost}</div>
          </div>
          <div class="dc-right">
            <div class="dc-name">${c.name}</div>
            <div class="dc-desc">${c.desc}</div>
          </div>
        </div>`;
    }
  });
  html += '</div>';

  document.getElementById('deck-viewer-content').innerHTML = html;
  document.getElementById('deck-viewer').style.display = 'flex';
}

// ===== CARD DICTIONARY =====
function toggleDictionary() {
  playSound('book');
  const dict = document.getElementById('card-dictionary');
  const toggle = document.getElementById('dict-toggle');
  if (dict.style.display === 'flex') {
    dict.style.display = 'none';
    toggle.classList.remove('open');
  } else {
    openDictionary();
    toggle.classList.add('open');
  }
}

function openDictionary() {
  if (!gameState) return;

  const myKey = (gameMode === 'ai' || gameState.currentPlayer === 'p1') ? 'p1' : 'p2';
  const myFaction = gameState[myKey].faction;
  const oppFaction = gameState[myKey === 'p1' ? 'p2' : 'p1'].faction;
  const myCards = FACTION_CONFIG[myFaction].cards;
  const oppCards = FACTION_CONFIG[oppFaction].cards;

  const title = document.getElementById('dict-title');
  const subtitle = document.getElementById('dict-subtitle');
  title.textContent = 'ì¹´ë“œ ë„ê°';
  subtitle.textContent = `ì „ì²´ ${myCards.length + oppCards.length}ì¢…`;

  let html = '';
  html += renderDictFaction(getFactionName(myFaction), myCards, getFactionClass(myFaction));
  html += renderDictFaction(getFactionName(oppFaction), oppCards, getFactionClass(oppFaction));

  document.getElementById('dict-content').innerHTML = html;
  document.getElementById('card-dictionary').style.display = 'flex';
}

function renderDictFaction(factionName, cards, fclass) {
  const minions = cards.filter(c => c.type === 'minion');
  const spells = cards.filter(c => c.type === 'spell');
  let html = '';

  html += `<div class="dict-section"><h3>${factionName} ë¯¸ë‹ˆì–¸ (${minions.length}ì¢…)</h3><div class="dict-grid">`;
  minions.forEach(c => {
    const kwText = (c.keywords || []).map(k => {
      switch(k) { case 'taunt': return 'ë„ë°œ'; case 'rush': return 'ëŒì§„'; case 'poison': return 'ë…'; case 'lifesteal': return 'í¡ìˆ˜'; default: return k; }
    }).join(', ');
    const desc = c.desc || kwText || '';
    html += `
      <div class="dict-card ${fclass}">
        <div class="dc-left">
          <div class="dc-emoji">${c.emoji}</div>
          <div class="dc-mana">${c.cost}</div>
        </div>
        <div class="dc-right">
          <div class="dc-name">${c.name}</div>
          <div class="dc-desc">${desc}</div>
          <div class="dc-stats"><div class="dc-atk">${c.attack}</div><div class="dc-hp">${c.health}</div></div>
        </div>
      </div>`;
  });
  html += '</div></div>';

  html += `<div class="dict-section"><h3>${factionName} ì£¼ë¬¸ (${spells.length}ì¢…)</h3><div class="dict-grid">`;
  spells.forEach(c => {
    html += `
      <div class="dict-card ${fclass}">
        <div class="dc-left">
          <div class="dc-emoji">${c.emoji}</div>
          <div class="dc-mana">${c.cost}</div>
        </div>
        <div class="dc-right">
          <div class="dc-name">${c.name}</div>
          <div class="dc-desc">${c.desc}</div>
        </div>
      </div>`;
  });
  html += '</div></div>';

  return html;
}

// ===== MENU DICTIONARY =====
function openMenuDictionary() {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('menu-dict-select').style.display = 'flex';

  // ì§„ì˜ ì„ íƒ ì¹´ë“œ ìƒì„±
  const container = document.getElementById('menu-dict-factions');
  container.innerHTML = '';
  Object.keys(FACTION_CONFIG).forEach(f => {
    const cfg = FACTION_CONFIG[f];
    const card = document.createElement('div');
    card.className = `faction-card ${f}`;
    card.innerHTML = `
      <div class="faction-icon">${cfg.emoji}</div>
      <h3>${cfg.name}</h3>
      <p>${cfg.cards.length}ì¢…</p>
    `;
    card.onclick = () => { playSound('book'); openMenuDictFaction(f); };
    container.appendChild(card);
  });
}

function openMenuDictFaction(faction) {
  document.getElementById('menu-dict-select').style.display = 'none';
  document.getElementById('menu-dictionary').style.display = 'flex';

  const cfg = FACTION_CONFIG[faction];
  document.getElementById('menu-dict-title').textContent = `ğŸ“– ${cfg.name} ì¹´ë“œ ë„ê°`;

  const html = renderDictFaction(cfg.name, cfg.cards, cfg.cardClass);
  document.getElementById('menu-dict-content').innerHTML = html;
}

function backToMenuDictSelect() {
  document.getElementById('menu-dictionary').style.display = 'none';
  document.getElementById('menu-dict-select').style.display = 'flex';
}

function closeMenuDictSelect() {
  document.getElementById('menu-dict-select').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
}

function openMenuSettings() {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('menu-settings').style.display = 'flex';
  syncSettingsUI();
}

function closeMenuSettings() {
  document.getElementById('menu-settings').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
}

function syncSettingsUI() {
  const val = Math.round(sfxVolume * 100);
  // ë©”ì¸ ë©”ë‰´ ì„¤ì •
  const menuSfx = document.getElementById('menu-sfx-toggle');
  const menuVol = document.getElementById('menu-volume-slider');
  const menuLabel = document.getElementById('menu-volume-label');
  if (menuSfx) menuSfx.checked = sfxEnabled;
  if (menuVol) menuVol.value = val;
  if (menuLabel) menuLabel.textContent = val + '%';
  // ê²Œì„ ë‚´ ì„¤ì •
  const gameSfx = document.getElementById('sfx-toggle');
  const gameVol = document.getElementById('volume-slider');
  const gameLabel = document.getElementById('volume-label');
  if (gameSfx) gameSfx.checked = sfxEnabled;
  if (gameVol) gameVol.value = val;
  if (gameLabel) gameLabel.textContent = val + '%';
}

function setVolume(val) {
  sfxVolume = val / 100;
  document.querySelectorAll('#volume-label, #menu-volume-label').forEach(el => el.textContent = val + '%');
  document.querySelectorAll('#volume-slider, #menu-volume-slider').forEach(el => el.value = val);
}

function toggleSfx(enabled) {
  sfxEnabled = enabled;
  document.querySelectorAll('#sfx-toggle, #menu-sfx-toggle').forEach(el => el.checked = enabled);
}
</script>
</body>
</html>
